{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\ude80 Welcome to greed's documentation! Welcome to greed's documentation! This documentation is intended to be a quick guide to use greed: our symbolic execution engine for EVM smart contract binaries. If greed makes you think of angr , that is because we are indeed from the same research group ( UCSB SecLab ). Some of the folks developing greed are also angr's contributor, thus, many of the choices in this project are inspired by angr. Note \ud83c\udf93 If you are using greed for an academic publication , we would really appreciate a citation to the following work: @inproceedings{gritti2023confusum, title={Confusum contractum: confused deputy vulnerabilities in ethereum smart contracts}, author={Gritti, Fabio and Ruaro, Nicola and McLaughlin, Robert and Bose, Priyanka and Das, Dipanjan and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={32nd USENIX Security Symposium (USENIX Security 23)}, pages={1793--1810}, year={2023} } @inproceedings{ruaro2024crush, title={Not your Type! Detecting Storage Collision Vulnerabilities in Ethereum Smart Contracts}, author={Ruaro, Nicola and Gritti, Fabio and McLaughlin, Robert and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={Network and Distributed Systems Security (NDSS) Symposium 2024}, year={2024} } Thanks!","title":"Home"},{"location":"#welcome-to-greeds-documentation","text":"Welcome to greed's documentation! This documentation is intended to be a quick guide to use greed: our symbolic execution engine for EVM smart contract binaries. If greed makes you think of angr , that is because we are indeed from the same research group ( UCSB SecLab ). Some of the folks developing greed are also angr's contributor, thus, many of the choices in this project are inspired by angr. Note \ud83c\udf93 If you are using greed for an academic publication , we would really appreciate a citation to the following work: @inproceedings{gritti2023confusum, title={Confusum contractum: confused deputy vulnerabilities in ethereum smart contracts}, author={Gritti, Fabio and Ruaro, Nicola and McLaughlin, Robert and Bose, Priyanka and Das, Dipanjan and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={32nd USENIX Security Symposium (USENIX Security 23)}, pages={1793--1810}, year={2023} } @inproceedings{ruaro2024crush, title={Not your Type! Detecting Storage Collision Vulnerabilities in Ethereum Smart Contracts}, author={Ruaro, Nicola and Gritti, Fabio and McLaughlin, Robert and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={Network and Distributed Systems Security (NDSS) Symposium 2024}, year={2024} } Thanks!","title":"\ud83d\ude80 Welcome to greed's documentation!"},{"location":"advanced/","text":"\ud83c\udf93 Advanced Topics State Plugins State plugins are (yet-another) concept that greed borrowed from angr. A state plugin is designed to carry any additional state context during its life-cycle. For instance, the default \"globals\" State Plugin can carry global variables useful for future decisions \u2013 such as the number of iterations of a specific loop. You can design your own State Plugin by implementing the SimStatePlugin interface and installing it to a SimState. The two main functions that need to be implemented when designing a custom plugin are: __init__ and copy . The former initializes the plugin with its default values, while the latter implements a deep copy of the plugin state (every plugin in a forking state must be copied to its successors). For example: from copy import deepcopy from greed.state_plugins import SimStatePlugin class mySimStateGlobals ( SimStatePlugin ): \"\"\" A plugin that allows for global variables to be stored in the state. \"\"\" def __init__ ( self , backer = None ): super ( mySimStateGlobals , self ) . __init__ () self . _backer = backer if backer is not None else dict () return ... def copy ( self ): new_backer = deepcopy ( self . _backer ) return mySimStateGlobals ( new_backer ) After creating a new plugin (e.g., mySimStateGlobals ) you can install it into a state with: >>> state . register_plugin ( \"myPluginName\" , mySimStateGlobals ()) Later, you can access the methods and attributes of your plugin using the installed name: >>> state . myPluginName . myMethod () Memory Model Symbolic memory reads and writes are arguably one of the most critical problems a symbolic executor must face to balance precision and scalability. Many different strategies have been proposed during the past years that range from nested ITE expressions to SMT Arrays to a more balanced segmented memory model (this paper does a pretty good job in providing an overview of all the currently available solutions). Our choice of memory model for greed landed on a design similar to that of Frank et al. in ETHBMC . Specifically, we leverage an extended version of the Theory of Arrays to model both the memory and the storage of a smart contract. We dubbed this memory model the \"LambdaMemory\". Thanks to the LambdaMemory, every memory operation in greed can be fully symbolic. Additionally, this allows to symbolically model \"memcopy\" operations triggered by opcodes such as CALLDATACOPY. While this memory model drastically improves the precision of symbolic execution, it also introduces additional complexity in the constraints and makes them hard to inspect. Specifically, differently from angr, inspecting a variable pulled from memory will merely show a Select operation rather than a more expressive ITE operation. Partial Concrete Storage Note To enable this mode, access to a web3 RPC endpoint is required. You can set the web3 provider via the option WEB3_PROVIDER in the greed options . If you don't have a private node, you can use any other provider such as Infura or Alchemy . A fully symbolic contract storage is not always a desirable option when performing symbolic execution. In fact, when analyzing the state of a contract at a specific block, you might want to use the concrete values in its storage to prune some unfeasible paths and simplify the symbolic execution. To do this, greed supports a \"Partial Concrete Storage\" mode that can be activated when creating a SimState: >>> ctx = { \"ADDRESS\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"NUMBER\" : 18808898 } >>> entry_state = p . factory . entry_state ( xid = xid , init_ctx = ctx , partial_concrete_storage = True ) When this mode is activated and greed encounters an SLOAD (let's say at slot id 0x5 ), greed will automatically fetch the concrete value of slot 0x5 in the contract's on-chain storage at block NUMBER ( 18808898 ) instead of using an unconstrained symbol. Similarly, any subsequent (and possibly symbolic) SSTORE at slot 0x5 will overwrite its value. In other words, you can imagine this mode of operation as a \"lazy\" initialization of the contract's storage in the symbolic executor that uses its on-chain storage at the specified block. External Calls Currently greed does not support external calls out-of-the-box. When one of the call opcodes ( CALL / DELEGATECALL / STATICCALL / CODECALL ) is executed during symbolic execution, our handlers simply \"skip\" the call and fill up the returned virtual register according to the option OPTIMISTIC_CALL_RESULTS . If OPTIMISTIC_CALL_RESULTS is active, greed will write the value 1 to the virtual register, indicating that the call was successfull. While this is enough for certain analyses, at other times it might be important to follow the execution flow and execute the opcodes in the target (called) contract. This is currently a feature that must be implemented on top of greed. Warning Implementing this feature requires particular care, especially in case of re-entrant code. Keccak256 In the EVM, the SHA3 opcode calculates the Keccak256 hash of a given input buffer. Tracking the constraints generated by cryptographic primitives such as SHA3 is notoriously impractical . Simply put, the complexity of such procedures generates extremely complex constraints and immediately overwhelms and stalls any state-of-the-art constraint solver. To overcome this issue, it is common practice to stub the SHA3 opcode, returning thus a fresh unconstrained symbolic variable and proceeding with the analysis. However, this requires extra care: the connection between the input and output of the SHA3 operation must be somehow modeled. To do this, we use an approach similar to that of ETHBMC , leveraging the Ackerman encoding for non-interpretable functions. In practice, we handle the SHA3 operations with a twofold strategy: (1) During symbolic execution, we record all the information regarding SHA operations in the sha_observed attribute of a SimState (i.e., the snapshot of the state's memory at the SHA operation, the offset at which the input buffer is located, and the size of the requested operation). For every observed SHA we return a fresh symbolic variable (e.g., <SHA1> ) and instantiate constraints that basically encode that the result of SHA3 opcodes that operate on equivalent input buffers MUST be the same. (2) When concretizing a symbolic variable, e.g.: to synthethize the CALLDATA to reach a specific instruction, we must first \"fix\" the values of the observed SHAs (if any). We provide a \"SHA resolution strategy\" that fixes the observed SHAs in chronological order. Namely, the strategy iterates over all the observed SHAs starting from the earliest, calculates a solution for its input buffer, calculates the corresponding Keccak256 hash, and finally assigns the result to the symbolic variable associated to this SHA. The process repeats for each observed SHA. Eventually, if it is possible to assign a concrete value to all the observed SHAs, the state is ready to be concretized. If it is not possible to find a solution, the state will be marked as unsat. Note that this process is not executed automatically, and must be explicitly called in your scripts. For example: shas = state . sha_resolver . fix_shas () Multi-Transactions Execution The state of a smart contract evolves across multiple transactions. With greed, you can symbolically execute a contract, save one of its states, and create a new transaction from such state. For example: for xid , calldata in more_transactions : entry_state = entry_state . copy () entry_state . reset ( xid = xid ) entry_state . set_init_ctx ({ \"CALLDATA\" : calldata }) entry_state . pc = project . factory . block ( '0x0' ) . first_ins . id simgr = project . factory . simgr ( entry_state = entry_state ) simgr . run ( find = lambda s : ( s . halt and not s . error and s . trace [ - 1 ] . __internal_name__ != 'REVERT' ) ) if not simgr . found : break entry_state = simgr . one_found","title":"Advanced Topics"},{"location":"advanced/#advanced-topics","text":"","title":"\ud83c\udf93 Advanced Topics"},{"location":"advanced/#state-plugins","text":"State plugins are (yet-another) concept that greed borrowed from angr. A state plugin is designed to carry any additional state context during its life-cycle. For instance, the default \"globals\" State Plugin can carry global variables useful for future decisions \u2013 such as the number of iterations of a specific loop. You can design your own State Plugin by implementing the SimStatePlugin interface and installing it to a SimState. The two main functions that need to be implemented when designing a custom plugin are: __init__ and copy . The former initializes the plugin with its default values, while the latter implements a deep copy of the plugin state (every plugin in a forking state must be copied to its successors). For example: from copy import deepcopy from greed.state_plugins import SimStatePlugin class mySimStateGlobals ( SimStatePlugin ): \"\"\" A plugin that allows for global variables to be stored in the state. \"\"\" def __init__ ( self , backer = None ): super ( mySimStateGlobals , self ) . __init__ () self . _backer = backer if backer is not None else dict () return ... def copy ( self ): new_backer = deepcopy ( self . _backer ) return mySimStateGlobals ( new_backer ) After creating a new plugin (e.g., mySimStateGlobals ) you can install it into a state with: >>> state . register_plugin ( \"myPluginName\" , mySimStateGlobals ()) Later, you can access the methods and attributes of your plugin using the installed name: >>> state . myPluginName . myMethod ()","title":"State Plugins"},{"location":"advanced/#memory-model","text":"Symbolic memory reads and writes are arguably one of the most critical problems a symbolic executor must face to balance precision and scalability. Many different strategies have been proposed during the past years that range from nested ITE expressions to SMT Arrays to a more balanced segmented memory model (this paper does a pretty good job in providing an overview of all the currently available solutions). Our choice of memory model for greed landed on a design similar to that of Frank et al. in ETHBMC . Specifically, we leverage an extended version of the Theory of Arrays to model both the memory and the storage of a smart contract. We dubbed this memory model the \"LambdaMemory\". Thanks to the LambdaMemory, every memory operation in greed can be fully symbolic. Additionally, this allows to symbolically model \"memcopy\" operations triggered by opcodes such as CALLDATACOPY. While this memory model drastically improves the precision of symbolic execution, it also introduces additional complexity in the constraints and makes them hard to inspect. Specifically, differently from angr, inspecting a variable pulled from memory will merely show a Select operation rather than a more expressive ITE operation.","title":"Memory Model"},{"location":"advanced/#partial-concrete-storage","text":"Note To enable this mode, access to a web3 RPC endpoint is required. You can set the web3 provider via the option WEB3_PROVIDER in the greed options . If you don't have a private node, you can use any other provider such as Infura or Alchemy . A fully symbolic contract storage is not always a desirable option when performing symbolic execution. In fact, when analyzing the state of a contract at a specific block, you might want to use the concrete values in its storage to prune some unfeasible paths and simplify the symbolic execution. To do this, greed supports a \"Partial Concrete Storage\" mode that can be activated when creating a SimState: >>> ctx = { \"ADDRESS\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"NUMBER\" : 18808898 } >>> entry_state = p . factory . entry_state ( xid = xid , init_ctx = ctx , partial_concrete_storage = True ) When this mode is activated and greed encounters an SLOAD (let's say at slot id 0x5 ), greed will automatically fetch the concrete value of slot 0x5 in the contract's on-chain storage at block NUMBER ( 18808898 ) instead of using an unconstrained symbol. Similarly, any subsequent (and possibly symbolic) SSTORE at slot 0x5 will overwrite its value. In other words, you can imagine this mode of operation as a \"lazy\" initialization of the contract's storage in the symbolic executor that uses its on-chain storage at the specified block.","title":"Partial Concrete Storage"},{"location":"advanced/#external-calls","text":"Currently greed does not support external calls out-of-the-box. When one of the call opcodes ( CALL / DELEGATECALL / STATICCALL / CODECALL ) is executed during symbolic execution, our handlers simply \"skip\" the call and fill up the returned virtual register according to the option OPTIMISTIC_CALL_RESULTS . If OPTIMISTIC_CALL_RESULTS is active, greed will write the value 1 to the virtual register, indicating that the call was successfull. While this is enough for certain analyses, at other times it might be important to follow the execution flow and execute the opcodes in the target (called) contract. This is currently a feature that must be implemented on top of greed. Warning Implementing this feature requires particular care, especially in case of re-entrant code.","title":"External Calls"},{"location":"advanced/#keccak256","text":"In the EVM, the SHA3 opcode calculates the Keccak256 hash of a given input buffer. Tracking the constraints generated by cryptographic primitives such as SHA3 is notoriously impractical . Simply put, the complexity of such procedures generates extremely complex constraints and immediately overwhelms and stalls any state-of-the-art constraint solver. To overcome this issue, it is common practice to stub the SHA3 opcode, returning thus a fresh unconstrained symbolic variable and proceeding with the analysis. However, this requires extra care: the connection between the input and output of the SHA3 operation must be somehow modeled. To do this, we use an approach similar to that of ETHBMC , leveraging the Ackerman encoding for non-interpretable functions. In practice, we handle the SHA3 operations with a twofold strategy: (1) During symbolic execution, we record all the information regarding SHA operations in the sha_observed attribute of a SimState (i.e., the snapshot of the state's memory at the SHA operation, the offset at which the input buffer is located, and the size of the requested operation). For every observed SHA we return a fresh symbolic variable (e.g., <SHA1> ) and instantiate constraints that basically encode that the result of SHA3 opcodes that operate on equivalent input buffers MUST be the same. (2) When concretizing a symbolic variable, e.g.: to synthethize the CALLDATA to reach a specific instruction, we must first \"fix\" the values of the observed SHAs (if any). We provide a \"SHA resolution strategy\" that fixes the observed SHAs in chronological order. Namely, the strategy iterates over all the observed SHAs starting from the earliest, calculates a solution for its input buffer, calculates the corresponding Keccak256 hash, and finally assigns the result to the symbolic variable associated to this SHA. The process repeats for each observed SHA. Eventually, if it is possible to assign a concrete value to all the observed SHAs, the state is ready to be concretized. If it is not possible to find a solution, the state will be marked as unsat. Note that this process is not executed automatically, and must be explicitly called in your scripts. For example: shas = state . sha_resolver . fix_shas ()","title":"Keccak256"},{"location":"advanced/#multi-transactions-execution","text":"The state of a smart contract evolves across multiple transactions. With greed, you can symbolically execute a contract, save one of its states, and create a new transaction from such state. For example: for xid , calldata in more_transactions : entry_state = entry_state . copy () entry_state . reset ( xid = xid ) entry_state . set_init_ctx ({ \"CALLDATA\" : calldata }) entry_state . pc = project . factory . block ( '0x0' ) . first_ins . id simgr = project . factory . simgr ( entry_state = entry_state ) simgr . run ( find = lambda s : ( s . halt and not s . error and s . trace [ - 1 ] . __internal_name__ != 'REVERT' ) ) if not simgr . found : break entry_state = simgr . one_found","title":"Multi-Transactions Execution"},{"location":"advice/","text":"\ud83e\uddd0 A Word of Advice Concretizing symbolic values When running greed, you will often find it helpful to concretize some symbolic values, for example, to inspect the actual value of a storage slot or to determine the concrete environment needed to reach a particular point in the execution (e.g., calldata). Remember that: (1) There are often inherent dependencies between symbolic values, and concretizing one might affect the satisfiability of the others. For example, to concretize the buffer of a SHA3 operation, you will first need to concretize its offset and size, or to concretize the calldata buffer, you might need first to concretize the \"calldatasize\" as well \u2013 unless it is already concrete or known: calldatasize = state . solver . eval ( state . calldatasize , raw = True ) calldata = state . solver . eval_memory ( state . calldata , calldatasize ) (2) When you set up a concrete transaction, you will need to provide values other than the calldata, for example, the value of msg.sender ( CALLER ) and the transferred amount ( VALUE ). You can derive all these values from your final state. For example: caller = state . solver . eval ( state . ctx [ 'CALLER' ]) . to_bytes ( 20 , 'big' ) . hex () callvalue = state . solver . eval ( state . ctx [ 'CALLVALUE' ]) log . info ( f 'CALLER: 0x { caller } ' ) log . info ( f 'CALLVALUE: 0x { callvalue } ' )","title":"Advice"},{"location":"advice/#a-word-of-advice","text":"","title":"\ud83e\uddd0 A Word of Advice"},{"location":"advice/#concretizing-symbolic-values","text":"When running greed, you will often find it helpful to concretize some symbolic values, for example, to inspect the actual value of a storage slot or to determine the concrete environment needed to reach a particular point in the execution (e.g., calldata). Remember that: (1) There are often inherent dependencies between symbolic values, and concretizing one might affect the satisfiability of the others. For example, to concretize the buffer of a SHA3 operation, you will first need to concretize its offset and size, or to concretize the calldata buffer, you might need first to concretize the \"calldatasize\" as well \u2013 unless it is already concrete or known: calldatasize = state . solver . eval ( state . calldatasize , raw = True ) calldata = state . solver . eval_memory ( state . calldata , calldatasize ) (2) When you set up a concrete transaction, you will need to provide values other than the calldata, for example, the value of msg.sender ( CALLER ) and the transferred amount ( VALUE ). You can derive all these values from your final state. For example: caller = state . solver . eval ( state . ctx [ 'CALLER' ]) . to_bytes ( 20 , 'big' ) . hex () callvalue = state . solver . eval ( state . ctx [ 'CALLVALUE' ]) log . info ( f 'CALLER: 0x { caller } ' ) log . info ( f 'CALLVALUE: 0x { callvalue } ' )","title":"Concretizing symbolic values"},{"location":"core/","text":"\ud83d\udd25 Core Concepts Overview greed relies on analyses provided by Gigahorse \u2013 a fantastic analysis framework for EVM-based smart contracts developed by Dedaub . While Gigahorse offers precise CFG reconstruction and various out-of-the-box data-flow analyses (such as storage layout partial reconstruction, tainted calls, etc.), it lacks the capability to perform classic symbolic execution of a contract's code. For example, it cannot automatically discover the value of CALLDATA needed to reach a specific instruction. Additionally, we found using Datalog rules (or via the produced artifacts) to be sometimes impractical for creating more complex analyses. This led to the creation of greed! When designing greed, we wanted to provide both a convenient Python wrapper for Gigahorse's analyses and symbolic execution capabilities similar to the popular tool Mythril . Unlike Mythril, we don't offer a one-click solution to discover smart contract vulnerabilities; instead, we provide a powerful and user-friendly smart contract binary analysis platform (those familiar with angr will find many similarities). That being said, one can implement all the analyses offered by Mythril on top of greed. We believe that greed provides a more flexible way to prototype research tools and smart contract analyses. This is accomplished through (1) a modular ( angr -inspired) design of the symbolic executor, (2) the inherited precision of the CFG analysis offered by Gigahorse , and (3) the conciseness of the TAC-IR (intermediate representation) that strips away the unnecessary complexities of the stack-based EVM design. To use greed, it is first necessary to analyze a target contract binary with Gigahorse, obtaining all the decompilation artifacts and CFG reconstruction. If you are just getting started with greed, please refer to our quick start guide ! Three Address Code Our symbolic executor, greed, is based on Gigahorse 's T(hree) A(ddress) C(ode) intermediate representation \u2013 TAC-IR: a convenient IR that transforms the (EVM) stack-based opcodes into a register based representation. For instance, the classic function transferFrom in TAC would look like this: function transferFrom ( address , address , uint256 )() public { Begin block 0x1ca prev = [], succ = [ 0x1d1 , 0x1d5 ] ================================= 0x1cb : v1cb = CALLVALUE 0x1cc : v1cc = ISZERO v1cb 0x1cd : v1cd ( 0x1d5 ) = CONST 0x1d0 : JUMPI v1cd ( 0x1d5 ), v1cc Begin block 0x1d1 prev = [ 0x1ca ], succ = [] ================================= 0x1d1 : v1d1 ( 0x0 ) = CONST 0x1d4 : REVERT v1d1 ( 0x0 ), v1d1 ( 0x0 ) ... One thing to keep in mind when using greed is: every variable defined by the TAC IR will become a virtual register. For instance, when you symbolically execute the transferFrom function, you can access to content of the variable v1cb like this: >>> state . registers [ 'v1cb' ] To access the value returned by the opcode CALLVALUE . Project To create a greed Project you will just: >>> from greed import Project >>> proj = Project ( target_dir = target_dir ) Where target_dir is the path to the folder holding the Gigahorse analyses artifacts. The project will import in greed some of the analysis results generated by Gigahorse (e.g., functions, blocks, and statements), and will make them available through handy object attributes: >>> proj . code # raw bytecode >>> proj . function_at # dictionary of all the functions in the contract >>> proj . block_at # dictionary of all the basic block in the contract >>> proj . statement_at # dictionary of all the (TAC) opcode in the contract >>> proj . callgraph # callgraph of the entire contract code CFG Gigahorse provides state-of-the-art CFG reconstruction for smart contract binaries. This information is automatically imported and available via the greed's API. Every basic block in the CFG is terminated by an unconditional jump (i.e., JUMP ), a conditional jump ( JUMPI ), or a terminating opcode ( STOP / REVERT / RETURN ). To access the CFG information of specific functions in the contract you can do the following: >>> proj . function_at [ '0x0' ] . cfg >>> proj . function_at [ '0x0' ] . cfg . dump ( \"mycfg.dot\" ) # this will dump the CFG in .dot format >>> proj . function_at [ '0x0' ] . cfg . bbs # this will return a list of block objects belonging to the CFG Similarly, to access a specific Block or Statement information: >>> block = proj . block_at [ '0x21' ] >>> stmt = proj . statement_at [ '0x1e' ] The Block and Statement objects, once fetched, offer numerous other attributes for advanced inspection. State Similary to angr, a SimState (i.e., State ) represents the state of the smart contract at a specific opcode. You can imagine the State as a snapshot of the execution at a specific program location. You can create your first state from a project using the Factory object: >>> entry_state = proj . factory . entry_state ( xid = 1 ) # the xid represent an unique identifier for the current symbolic execution. When no initial context is specified, every environment variable (e.g., balance, calldata, calldata size, block, etc...) will be an unconstrained symbolic variable. Conversely, you can pass an initial context by passing a dictionary and specifying some concrete values: >>> ctx = { \"CALLDATA\" : \"0x001122330099aabb77ff00\" , \"CALLDATASIZE\" : 11 , \"CALLER\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ORIGIN\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ADDRESS\" : \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\" , } >>> entry_state = proj . factory . entry_state ( xid = 1 , init_ctx = ctx ) This will set the the CALLDATA for the symbolic execution to the value 0x001122330099aabb77ff00 , a CALLDATASIZE of 11 bytes, ADDRESS of the currently executing contract to 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984 and CALLER / ORIGIN to 0x6b6Ae9eDA977833B379f4b49655124b4e5c64086 . A state offers many API for its inspection: >>> entry_state . curr_stmt # print the current statement ready for execution >>> entry_state . revert # weather the state reverted or not >>> entry_state . instruction_count # how many instructions have been executed up to this point >>> entry_state . pc # current program counter >>> entry_state . registers # overview of all the virtual registers defined during the execution up to this point Symbolic Execution Symbolic execution is the process of progressing SimState(s) and propagating the symbolic variables according to the program's execution. Imagine, for instance, that the condition of a JUMPI contains a symbolic variable X. If the condition checks for X != 0 , and the constraints over the variable X make it possible for X != 0 and X == 0 , greed will create two different State(s), one at the location specified by the JUMPI (adding a constraint of X != 0 to the state), and one at the fallthrough location (adding a constraint of X == 0 ). Simulation Manager To begin symbolic execution you need to instantiate a Simulation Manager . The simulation manager is a concept borrowed from angr, used to orchestrate the progression of the SimState(s). Exploration Techniques can be used to provide a strategy to explore the states of the program. For instance, an exploration technique could be the classic breadth-first search (BFS) or depth-first search (DFS), but also more complicated strategies such as Directed Search. You can instantiate a simulation manager via the Factory in this way: >>> simgr = proj . factory . simgr ( entry_state = entry_state ) By default, the employed exploration technique will be BFS. You can change this behavior by installing new exploration techniques that implement the Exploration Technique object interface. For example: >>> from greed.exploration_techniques import DirectedSearch >>> directed_search = DirectedSearch ( proj . statement_at [ '0x1e' ]) >>> simgr . use_technique ( directed_search ) Finally, to start the exploration: >>> simgr . run () The simulation manager operates using stashes . You can imagine a stash as a \"bucket\" of states generated by the simulation manager during symbolic execution. For example, the stash active contains all the states that are currently \"active\" in the simulation manager. The simulation manager will process (or \"step\") every state in the active stash individually to create a successor state. If the state has no successors, the simulation manager will move the state to the deadended stash. If the execution instead terminates with a REVERT opcode, the state will be moved to the errored stash. Exploration techniques can defined new stashes to implement more complicated program exploration strategies. Solver The default solver employed by greed is Yices2 with QF_ABV logic. We made this decision based on the impressive results obtained in the latest SMT solving competition, and based on the results showed by Frank et al. in ETHBMC . That being said, greed offers a modular architecure and implementing support for a new solver backend is quite straigthforward. By default, we give unlimited time to the solver to solve the constraints. However, it can be sometimes helpful to timeout after a certain amount of time. You can do this by using the option SOLVER_TIMEOUT . Keep in mind that, when the timeout fires, the state will be reported as errored .","title":"Core Concepts"},{"location":"core/#core-concepts","text":"","title":"\ud83d\udd25 Core Concepts"},{"location":"core/#overview","text":"greed relies on analyses provided by Gigahorse \u2013 a fantastic analysis framework for EVM-based smart contracts developed by Dedaub . While Gigahorse offers precise CFG reconstruction and various out-of-the-box data-flow analyses (such as storage layout partial reconstruction, tainted calls, etc.), it lacks the capability to perform classic symbolic execution of a contract's code. For example, it cannot automatically discover the value of CALLDATA needed to reach a specific instruction. Additionally, we found using Datalog rules (or via the produced artifacts) to be sometimes impractical for creating more complex analyses. This led to the creation of greed! When designing greed, we wanted to provide both a convenient Python wrapper for Gigahorse's analyses and symbolic execution capabilities similar to the popular tool Mythril . Unlike Mythril, we don't offer a one-click solution to discover smart contract vulnerabilities; instead, we provide a powerful and user-friendly smart contract binary analysis platform (those familiar with angr will find many similarities). That being said, one can implement all the analyses offered by Mythril on top of greed. We believe that greed provides a more flexible way to prototype research tools and smart contract analyses. This is accomplished through (1) a modular ( angr -inspired) design of the symbolic executor, (2) the inherited precision of the CFG analysis offered by Gigahorse , and (3) the conciseness of the TAC-IR (intermediate representation) that strips away the unnecessary complexities of the stack-based EVM design. To use greed, it is first necessary to analyze a target contract binary with Gigahorse, obtaining all the decompilation artifacts and CFG reconstruction. If you are just getting started with greed, please refer to our quick start guide !","title":"Overview"},{"location":"core/#three-address-code","text":"Our symbolic executor, greed, is based on Gigahorse 's T(hree) A(ddress) C(ode) intermediate representation \u2013 TAC-IR: a convenient IR that transforms the (EVM) stack-based opcodes into a register based representation. For instance, the classic function transferFrom in TAC would look like this: function transferFrom ( address , address , uint256 )() public { Begin block 0x1ca prev = [], succ = [ 0x1d1 , 0x1d5 ] ================================= 0x1cb : v1cb = CALLVALUE 0x1cc : v1cc = ISZERO v1cb 0x1cd : v1cd ( 0x1d5 ) = CONST 0x1d0 : JUMPI v1cd ( 0x1d5 ), v1cc Begin block 0x1d1 prev = [ 0x1ca ], succ = [] ================================= 0x1d1 : v1d1 ( 0x0 ) = CONST 0x1d4 : REVERT v1d1 ( 0x0 ), v1d1 ( 0x0 ) ... One thing to keep in mind when using greed is: every variable defined by the TAC IR will become a virtual register. For instance, when you symbolically execute the transferFrom function, you can access to content of the variable v1cb like this: >>> state . registers [ 'v1cb' ] To access the value returned by the opcode CALLVALUE .","title":"Three Address Code"},{"location":"core/#project","text":"To create a greed Project you will just: >>> from greed import Project >>> proj = Project ( target_dir = target_dir ) Where target_dir is the path to the folder holding the Gigahorse analyses artifacts. The project will import in greed some of the analysis results generated by Gigahorse (e.g., functions, blocks, and statements), and will make them available through handy object attributes: >>> proj . code # raw bytecode >>> proj . function_at # dictionary of all the functions in the contract >>> proj . block_at # dictionary of all the basic block in the contract >>> proj . statement_at # dictionary of all the (TAC) opcode in the contract >>> proj . callgraph # callgraph of the entire contract code","title":"Project"},{"location":"core/#cfg","text":"Gigahorse provides state-of-the-art CFG reconstruction for smart contract binaries. This information is automatically imported and available via the greed's API. Every basic block in the CFG is terminated by an unconditional jump (i.e., JUMP ), a conditional jump ( JUMPI ), or a terminating opcode ( STOP / REVERT / RETURN ). To access the CFG information of specific functions in the contract you can do the following: >>> proj . function_at [ '0x0' ] . cfg >>> proj . function_at [ '0x0' ] . cfg . dump ( \"mycfg.dot\" ) # this will dump the CFG in .dot format >>> proj . function_at [ '0x0' ] . cfg . bbs # this will return a list of block objects belonging to the CFG Similarly, to access a specific Block or Statement information: >>> block = proj . block_at [ '0x21' ] >>> stmt = proj . statement_at [ '0x1e' ] The Block and Statement objects, once fetched, offer numerous other attributes for advanced inspection.","title":"CFG"},{"location":"core/#state","text":"Similary to angr, a SimState (i.e., State ) represents the state of the smart contract at a specific opcode. You can imagine the State as a snapshot of the execution at a specific program location. You can create your first state from a project using the Factory object: >>> entry_state = proj . factory . entry_state ( xid = 1 ) # the xid represent an unique identifier for the current symbolic execution. When no initial context is specified, every environment variable (e.g., balance, calldata, calldata size, block, etc...) will be an unconstrained symbolic variable. Conversely, you can pass an initial context by passing a dictionary and specifying some concrete values: >>> ctx = { \"CALLDATA\" : \"0x001122330099aabb77ff00\" , \"CALLDATASIZE\" : 11 , \"CALLER\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ORIGIN\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ADDRESS\" : \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\" , } >>> entry_state = proj . factory . entry_state ( xid = 1 , init_ctx = ctx ) This will set the the CALLDATA for the symbolic execution to the value 0x001122330099aabb77ff00 , a CALLDATASIZE of 11 bytes, ADDRESS of the currently executing contract to 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984 and CALLER / ORIGIN to 0x6b6Ae9eDA977833B379f4b49655124b4e5c64086 . A state offers many API for its inspection: >>> entry_state . curr_stmt # print the current statement ready for execution >>> entry_state . revert # weather the state reverted or not >>> entry_state . instruction_count # how many instructions have been executed up to this point >>> entry_state . pc # current program counter >>> entry_state . registers # overview of all the virtual registers defined during the execution up to this point","title":"State"},{"location":"core/#symbolic-execution","text":"Symbolic execution is the process of progressing SimState(s) and propagating the symbolic variables according to the program's execution. Imagine, for instance, that the condition of a JUMPI contains a symbolic variable X. If the condition checks for X != 0 , and the constraints over the variable X make it possible for X != 0 and X == 0 , greed will create two different State(s), one at the location specified by the JUMPI (adding a constraint of X != 0 to the state), and one at the fallthrough location (adding a constraint of X == 0 ).","title":"Symbolic Execution"},{"location":"core/#simulation-manager","text":"To begin symbolic execution you need to instantiate a Simulation Manager . The simulation manager is a concept borrowed from angr, used to orchestrate the progression of the SimState(s). Exploration Techniques can be used to provide a strategy to explore the states of the program. For instance, an exploration technique could be the classic breadth-first search (BFS) or depth-first search (DFS), but also more complicated strategies such as Directed Search. You can instantiate a simulation manager via the Factory in this way: >>> simgr = proj . factory . simgr ( entry_state = entry_state ) By default, the employed exploration technique will be BFS. You can change this behavior by installing new exploration techniques that implement the Exploration Technique object interface. For example: >>> from greed.exploration_techniques import DirectedSearch >>> directed_search = DirectedSearch ( proj . statement_at [ '0x1e' ]) >>> simgr . use_technique ( directed_search ) Finally, to start the exploration: >>> simgr . run () The simulation manager operates using stashes . You can imagine a stash as a \"bucket\" of states generated by the simulation manager during symbolic execution. For example, the stash active contains all the states that are currently \"active\" in the simulation manager. The simulation manager will process (or \"step\") every state in the active stash individually to create a successor state. If the state has no successors, the simulation manager will move the state to the deadended stash. If the execution instead terminates with a REVERT opcode, the state will be moved to the errored stash. Exploration techniques can defined new stashes to implement more complicated program exploration strategies.","title":"Simulation Manager"},{"location":"core/#solver","text":"The default solver employed by greed is Yices2 with QF_ABV logic. We made this decision based on the impressive results obtained in the latest SMT solving competition, and based on the results showed by Frank et al. in ETHBMC . That being said, greed offers a modular architecure and implementing support for a new solver backend is quite straigthforward. By default, we give unlimited time to the solver to solve the constraints. However, it can be sometimes helpful to timeout after a certain amount of time. You can do this by using the option SOLVER_TIMEOUT . Keep in mind that, when the timeout fires, the state will be reported as errored .","title":"Solver"},{"location":"credits/","text":"\ud83d\udc65 Credits greed is currently mainly maintained by degrigis and ruaronicola and the following contributors: While we are available for discussions and bug fixes (via GitHub Issues), we have limited resources to provide any full-time support or feature requests at the time of writing. Thus, we provide the tool as it is. Note If you are using greed for an academic publication, we would really appreciate a citation to the following work: @inproceedings{gritti2023confusum, title={Confusum contractum: confused deputy vulnerabilities in ethereum smart contracts}, author={Gritti, Fabio and Ruaro, Nicola and McLaughlin, Robert and Bose, Priyanka and Das, Dipanjan and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={32nd USENIX Security Symposium (USENIX Security 23)}, pages={1793--1810}, year={2023} } @inproceedings{ruaro2024crush, title={Not your Type! Detecting Storage Collision Vulnerabilities in Ethereum Smart Contracts}, author={Ruaro, Nicola and Gritti, Fabio and McLaughlin, Robert and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={Network and Distributed Systems Security (NDSS) Symposium 2024}, year={2024} } Thanks!","title":"Credits"},{"location":"credits/#credits","text":"greed is currently mainly maintained by degrigis and ruaronicola and the following contributors: While we are available for discussions and bug fixes (via GitHub Issues), we have limited resources to provide any full-time support or feature requests at the time of writing. Thus, we provide the tool as it is. Note If you are using greed for an academic publication, we would really appreciate a citation to the following work: @inproceedings{gritti2023confusum, title={Confusum contractum: confused deputy vulnerabilities in ethereum smart contracts}, author={Gritti, Fabio and Ruaro, Nicola and McLaughlin, Robert and Bose, Priyanka and Das, Dipanjan and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={32nd USENIX Security Symposium (USENIX Security 23)}, pages={1793--1810}, year={2023} } @inproceedings{ruaro2024crush, title={Not your Type! Detecting Storage Collision Vulnerabilities in Ethereum Smart Contracts}, author={Ruaro, Nicola and Gritti, Fabio and McLaughlin, Robert and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni}, booktitle={Network and Distributed Systems Security (NDSS) Symposium 2024}, year={2024} } Thanks!","title":"\ud83d\udc65 Credits"},{"location":"examples/","text":"\ud83d\udc23 Examples Here we show some examples to demonstrate the usage of some of the greed APIs and how to levereage them to accomplish a few interesting tasks. (1) Reachibility of a CALL statement In this example, we show how to automatically synthetize the CALLDATA to reach an arbitrary CALL statement in an unverified contract 0x204Db9Ca00912c0F9e6380342113f6A0147E6f8C on chain. First, you should download the contract bytecode and place it in a contract.hex file: $ cat contract.hex 0x6080604052600436106100595760003560e... Then, use our script analyze_hex.sh (shipped with greed) to run Gigahorse against it: ( the script is in the /greed/resources/ folder) $ analyze_hex.sh --file ./contract.hex This will produce many artifacts in the current folder: $ ls ActualReturnArgs.csv AllCALLsClassified.csv Analytics_ArrayCopy.csv Analytics_ArrayHasTwoElementLengths.csv Analytics_BlockHasNoTACBlock.csv Analytics_BlockInMultipleFunctions.csv Analytics_BlockInNoFunctions.csv Analytics_BlockIsEmpty.csv [ ... ] Now, we have everything we need to start using greed! This is our example analysis script to automatically generate the CALLDATA needed to reach the target CALL statement (follow the comments). import logging from greed import Project , options from greed.exploration_techniques import ExplorationTechnique , DirectedSearch , HeartBeat , Prioritizer , DFS from greed.utils.extra import gen_exec_id from greed.solver.shortcuts import * LOGGING_FORMAT = \" %(levelname)s | %(message)s \" logging . basicConfig ( level = logging . INFO , format = LOGGING_FORMAT ) log = logging . getLogger ( \"example\" ) log . setLevel ( logging . INFO ) def config_greed (): options . WEB3_PROVIDER = 'http://0.0.0.0:8545' # your web3 RPC node. options . GREEDY_SHA = True options . LAZY_SOLVES = False options . STATE_INSPECT = True options . MAX_SHA_SIZE = 300 options . OPTIMISTIC_CALL_RESULTS = True options . DEFAULT_EXTCODESIZE = True options . DEFAULT_CREATE2_RESULT_ADDRESS = True options . DEFAULT_CREATE_RESULT_ADDRESS = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_EXP = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_BASE = True def main (): config_greed () block_ref = 16489409 # This is the PC of the target call #(according to the contract.tac file in the Gigahorse analysis folder ) call_pc = \"0x1f7\" # Create the greed project proj = Project ( target_dir = \"./contracts/0x204Db9Ca00912c0F9e6380342113f6A0147E6f8C/\" ) # We want to reach this call statement call_stmt = proj . statement_at [ call_pc ] # Get information about the block to concretize the block context block_info = proj . w3 . eth . get_block ( block_ref ) # Create the initial context init_ctx = { \"CALLER\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ORIGIN\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ADDRESS\" : \"0x204Db9Ca00912c0F9e6380342113f6A0147E6f8C\" , \"NUMBER\" : block_info . number , \"DIFFICULTY\" : block_info [ \"totalDifficulty\" ], \"TIMESTAMP\" : block_info [ \"timestamp\" ] } # Generate a new execution id xid = gen_exec_id () # Create the entry state entry_state = proj . factory . entry_state ( xid = xid , init_ctx = init_ctx , max_calldatasize = 2048 , partial_concrete_storage = True ) # Setting up the simulation manager! simgr = proj . factory . simgr ( entry_state = entry_state ) # Enabling directed symbolic execution directed_search = DirectedSearch ( call_stmt ) simgr . use_technique ( directed_search ) # Together with the prioritizer, this technique will prioritize states that are closer to the target prioritizer = Prioritizer ( scoring_function = lambda s : - s . globals [ 'directed_search_distance' ]) simgr . use_technique ( prioritizer ) # Some nice output :) heartbeat = HeartBeat ( beat_interval = 1 , show_op = True ) simgr . use_technique ( heartbeat ) print ( f \" Symbolically executing...\" ) while True : try : # Run the simulation manager until we reach the call statement simgr . run ( find = lambda s : s . curr_stmt . id == call_stmt . id ) except Exception as e : print ( e ) continue # Found a state at the call statement! if len ( simgr . found ) == 1 : print ( f \" \u2705 Found state for { call_stmt . __internal_name__ } at { call_stmt . id } !\" ) state = simgr . one_found # Get a solution for the calldata, this is the value that we should pass to # reach the call statement! calldata_sol = state . solver . eval_memory ( state . calldata , length = BVV ( 1024 , 256 )) print ( f \" \ud83d\udce5 Calldata: { calldata_sol } \" ) break elif len ( simgr . found ) == 0 : # if we are here, it is not possible to reach the call statement given # the current context print ( f \" \u274c No state found for { call_stmt . __internal_name__ } at { call_stmt . id } !\" ) break if __name__ == \"__main__\" : main () (2) Mint a PudgyPenguin In this example we show how one can synthetize the CALLDATA and the CALLVALUE necessary to mint() a PudgyPenguin(\ud83d\udc27) in the contract at 0xBd3531dA5CF5857e7CfAA92426877b022e612cf8 . After analyzing the contract as explained in the previous example, you can use the following script: import web3 import logging from greed import Project , options from greed.exploration_techniques import ExplorationTechnique , DirectedSearch , HeartBeat , Prioritizer , DFS from greed.utils.extra import gen_exec_id from greed.solver.shortcuts import * LOGGING_FORMAT = \" %(levelname)s | %(message)s \" logging . basicConfig ( level = logging . INFO , format = LOGGING_FORMAT ) log = logging . getLogger ( \"example\" ) log . setLevel ( logging . INFO ) def config_greed (): options . GREEDY_SHA = True options . LAZY_SOLVES = False options . STATE_INSPECT = True options . MAX_SHA_SIZE = 300 options . OPTIMISTIC_CALL_RESULTS = True options . DEFAULT_EXTCODESIZE = True options . DEFAULT_CREATE2_RESULT_ADDRESS = True options . DEFAULT_CREATE_RESULT_ADDRESS = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_EXP = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_BASE = True def main (): config_greed () # 4 bytes of the mint() function # 0 --> 3 calldata = \"0x40c10f19\" block_ref = 12878195 # Create the greed project proj = Project ( target_dir = \"./contracts/0xBd3531dA5CF5857e7CfAA92426877b022e612cf8/\" ) # this is the pc of the STOP opcode in the mint function STOP = \"0x43f\" stop_stmt = proj . statement_at [ STOP ] block_info = proj . w3 . eth . get_block ( block_ref ) # Let's set the CALLER to my account init_ctx = { \"CALLDATA\" : calldata , \"CALLER\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ORIGIN\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ADDRESS\" : \"0xBd3531dA5CF5857e7CfAA92426877b022e612cf8\" , \"NUMBER\" : block_info . number , \"DIFFICULTY\" : block_info [ \"totalDifficulty\" ], \"TIMESTAMP\" : block_info [ \"timestamp\" ] } xid = gen_exec_id () # Create the entry state entry_state = proj . factory . entry_state ( xid = xid , init_ctx = init_ctx , max_calldatasize = 68 , partial_concrete_storage = True ) # The second argument of mint is the \"amount\" of penguins to mint, we want that to be non-zero! entry_state . add_constraint ( NotEqual ( entry_state . calldata [ BVV ( 67 , 256 )], BVV ( 0 , 8 ))) # Set a constraint on the CALLVALUE entry_state . add_constraint ( BV_ULE ( entry_state . ctx [ 'CALLVALUE' ], BVV ( 0x6000000000000000 , 256 ))) # When a Penguin is minted, we see a LOG4, let's setup an inspection # point and show a message! def hi ( simgr , state ): log . debug ( f 'Emitted LOG4 at { state . curr_stmt . id } !' ) entry_state . inspect . stop_at_stmt ( stmt_name = \"LOG4\" , func = hi ) # Setting up the simulation manager simgr = proj . factory . simgr ( entry_state = entry_state ) directed_search = DirectedSearch ( stop_stmt ) simgr . use_technique ( directed_search ) prioritizer = Prioritizer ( scoring_function = lambda s : - s . globals [ 'directed_search_distance' ]) simgr . use_technique ( prioritizer ) heartbeat = HeartBeat ( beat_interval = 100 , show_op = True ) simgr . use_technique ( heartbeat ) print ( f \" Symbolically executing...\" ) while True : try : simgr . run ( find = lambda s : s . curr_stmt . id == stop_stmt . id ) except Exception as e : print ( e ) continue if len ( simgr . found ) == 1 : print ( f \" \u2705 Found state for { stop_stmt . __internal_name__ } at { stop_stmt . id } !\" ) state = simgr . one_found # Fix the shas! if len ( state . sha_observed ) > 0 : shas = state . sha_resolver . fix_shas () print ( f 'Fixed { len ( shas ) } shas in the state!' ) # Get a solution for the CALLDATA calldata_sol = state . solver . eval_memory ( state . calldata , length = BVV ( 68 , 256 ), raw = True ) # Get a solution for CALLVALUE (i.e., how much we paid for a penguin) # (Note: Yices2 does not expose a min() function, but you can find the minimum value # by using a bisection search) callvalue = state . solver . eval ( state . ctx [ 'CALLVALUE' ]) print ( f \" \ud83d\udce5 Calldata: { hex ( bv_unsigned_value ( calldata_sol )) } \" ) print ( f \" \ud83d\udcb8 Callvalue: { callvalue } \" ) break elif len ( simgr . found ) == 0 : print ( f \" \u274c No state found for { stop_stmt . __internal_name__ } at { stop_stmt . id } !\" ) break if __name__ == \"__main__\" : main ()","title":"Examples"},{"location":"examples/#examples","text":"Here we show some examples to demonstrate the usage of some of the greed APIs and how to levereage them to accomplish a few interesting tasks.","title":"\ud83d\udc23 Examples"},{"location":"examples/#1-reachibility-of-a-call-statement","text":"In this example, we show how to automatically synthetize the CALLDATA to reach an arbitrary CALL statement in an unverified contract 0x204Db9Ca00912c0F9e6380342113f6A0147E6f8C on chain. First, you should download the contract bytecode and place it in a contract.hex file: $ cat contract.hex 0x6080604052600436106100595760003560e... Then, use our script analyze_hex.sh (shipped with greed) to run Gigahorse against it: ( the script is in the /greed/resources/ folder) $ analyze_hex.sh --file ./contract.hex This will produce many artifacts in the current folder: $ ls ActualReturnArgs.csv AllCALLsClassified.csv Analytics_ArrayCopy.csv Analytics_ArrayHasTwoElementLengths.csv Analytics_BlockHasNoTACBlock.csv Analytics_BlockInMultipleFunctions.csv Analytics_BlockInNoFunctions.csv Analytics_BlockIsEmpty.csv [ ... ] Now, we have everything we need to start using greed! This is our example analysis script to automatically generate the CALLDATA needed to reach the target CALL statement (follow the comments). import logging from greed import Project , options from greed.exploration_techniques import ExplorationTechnique , DirectedSearch , HeartBeat , Prioritizer , DFS from greed.utils.extra import gen_exec_id from greed.solver.shortcuts import * LOGGING_FORMAT = \" %(levelname)s | %(message)s \" logging . basicConfig ( level = logging . INFO , format = LOGGING_FORMAT ) log = logging . getLogger ( \"example\" ) log . setLevel ( logging . INFO ) def config_greed (): options . WEB3_PROVIDER = 'http://0.0.0.0:8545' # your web3 RPC node. options . GREEDY_SHA = True options . LAZY_SOLVES = False options . STATE_INSPECT = True options . MAX_SHA_SIZE = 300 options . OPTIMISTIC_CALL_RESULTS = True options . DEFAULT_EXTCODESIZE = True options . DEFAULT_CREATE2_RESULT_ADDRESS = True options . DEFAULT_CREATE_RESULT_ADDRESS = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_EXP = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_BASE = True def main (): config_greed () block_ref = 16489409 # This is the PC of the target call #(according to the contract.tac file in the Gigahorse analysis folder ) call_pc = \"0x1f7\" # Create the greed project proj = Project ( target_dir = \"./contracts/0x204Db9Ca00912c0F9e6380342113f6A0147E6f8C/\" ) # We want to reach this call statement call_stmt = proj . statement_at [ call_pc ] # Get information about the block to concretize the block context block_info = proj . w3 . eth . get_block ( block_ref ) # Create the initial context init_ctx = { \"CALLER\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ORIGIN\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ADDRESS\" : \"0x204Db9Ca00912c0F9e6380342113f6A0147E6f8C\" , \"NUMBER\" : block_info . number , \"DIFFICULTY\" : block_info [ \"totalDifficulty\" ], \"TIMESTAMP\" : block_info [ \"timestamp\" ] } # Generate a new execution id xid = gen_exec_id () # Create the entry state entry_state = proj . factory . entry_state ( xid = xid , init_ctx = init_ctx , max_calldatasize = 2048 , partial_concrete_storage = True ) # Setting up the simulation manager! simgr = proj . factory . simgr ( entry_state = entry_state ) # Enabling directed symbolic execution directed_search = DirectedSearch ( call_stmt ) simgr . use_technique ( directed_search ) # Together with the prioritizer, this technique will prioritize states that are closer to the target prioritizer = Prioritizer ( scoring_function = lambda s : - s . globals [ 'directed_search_distance' ]) simgr . use_technique ( prioritizer ) # Some nice output :) heartbeat = HeartBeat ( beat_interval = 1 , show_op = True ) simgr . use_technique ( heartbeat ) print ( f \" Symbolically executing...\" ) while True : try : # Run the simulation manager until we reach the call statement simgr . run ( find = lambda s : s . curr_stmt . id == call_stmt . id ) except Exception as e : print ( e ) continue # Found a state at the call statement! if len ( simgr . found ) == 1 : print ( f \" \u2705 Found state for { call_stmt . __internal_name__ } at { call_stmt . id } !\" ) state = simgr . one_found # Get a solution for the calldata, this is the value that we should pass to # reach the call statement! calldata_sol = state . solver . eval_memory ( state . calldata , length = BVV ( 1024 , 256 )) print ( f \" \ud83d\udce5 Calldata: { calldata_sol } \" ) break elif len ( simgr . found ) == 0 : # if we are here, it is not possible to reach the call statement given # the current context print ( f \" \u274c No state found for { call_stmt . __internal_name__ } at { call_stmt . id } !\" ) break if __name__ == \"__main__\" : main ()","title":"(1) Reachibility of a CALL statement"},{"location":"examples/#2-mint-a-pudgypenguin","text":"In this example we show how one can synthetize the CALLDATA and the CALLVALUE necessary to mint() a PudgyPenguin(\ud83d\udc27) in the contract at 0xBd3531dA5CF5857e7CfAA92426877b022e612cf8 . After analyzing the contract as explained in the previous example, you can use the following script: import web3 import logging from greed import Project , options from greed.exploration_techniques import ExplorationTechnique , DirectedSearch , HeartBeat , Prioritizer , DFS from greed.utils.extra import gen_exec_id from greed.solver.shortcuts import * LOGGING_FORMAT = \" %(levelname)s | %(message)s \" logging . basicConfig ( level = logging . INFO , format = LOGGING_FORMAT ) log = logging . getLogger ( \"example\" ) log . setLevel ( logging . INFO ) def config_greed (): options . GREEDY_SHA = True options . LAZY_SOLVES = False options . STATE_INSPECT = True options . MAX_SHA_SIZE = 300 options . OPTIMISTIC_CALL_RESULTS = True options . DEFAULT_EXTCODESIZE = True options . DEFAULT_CREATE2_RESULT_ADDRESS = True options . DEFAULT_CREATE_RESULT_ADDRESS = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_EXP = True options . MATH_CONCRETIZE_SYMBOLIC_EXP_BASE = True def main (): config_greed () # 4 bytes of the mint() function # 0 --> 3 calldata = \"0x40c10f19\" block_ref = 12878195 # Create the greed project proj = Project ( target_dir = \"./contracts/0xBd3531dA5CF5857e7CfAA92426877b022e612cf8/\" ) # this is the pc of the STOP opcode in the mint function STOP = \"0x43f\" stop_stmt = proj . statement_at [ STOP ] block_info = proj . w3 . eth . get_block ( block_ref ) # Let's set the CALLER to my account init_ctx = { \"CALLDATA\" : calldata , \"CALLER\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ORIGIN\" : \"0x6b6Ae9eDA977833B379f4b49655124b4e5c64086\" , \"ADDRESS\" : \"0xBd3531dA5CF5857e7CfAA92426877b022e612cf8\" , \"NUMBER\" : block_info . number , \"DIFFICULTY\" : block_info [ \"totalDifficulty\" ], \"TIMESTAMP\" : block_info [ \"timestamp\" ] } xid = gen_exec_id () # Create the entry state entry_state = proj . factory . entry_state ( xid = xid , init_ctx = init_ctx , max_calldatasize = 68 , partial_concrete_storage = True ) # The second argument of mint is the \"amount\" of penguins to mint, we want that to be non-zero! entry_state . add_constraint ( NotEqual ( entry_state . calldata [ BVV ( 67 , 256 )], BVV ( 0 , 8 ))) # Set a constraint on the CALLVALUE entry_state . add_constraint ( BV_ULE ( entry_state . ctx [ 'CALLVALUE' ], BVV ( 0x6000000000000000 , 256 ))) # When a Penguin is minted, we see a LOG4, let's setup an inspection # point and show a message! def hi ( simgr , state ): log . debug ( f 'Emitted LOG4 at { state . curr_stmt . id } !' ) entry_state . inspect . stop_at_stmt ( stmt_name = \"LOG4\" , func = hi ) # Setting up the simulation manager simgr = proj . factory . simgr ( entry_state = entry_state ) directed_search = DirectedSearch ( stop_stmt ) simgr . use_technique ( directed_search ) prioritizer = Prioritizer ( scoring_function = lambda s : - s . globals [ 'directed_search_distance' ]) simgr . use_technique ( prioritizer ) heartbeat = HeartBeat ( beat_interval = 100 , show_op = True ) simgr . use_technique ( heartbeat ) print ( f \" Symbolically executing...\" ) while True : try : simgr . run ( find = lambda s : s . curr_stmt . id == stop_stmt . id ) except Exception as e : print ( e ) continue if len ( simgr . found ) == 1 : print ( f \" \u2705 Found state for { stop_stmt . __internal_name__ } at { stop_stmt . id } !\" ) state = simgr . one_found # Fix the shas! if len ( state . sha_observed ) > 0 : shas = state . sha_resolver . fix_shas () print ( f 'Fixed { len ( shas ) } shas in the state!' ) # Get a solution for the CALLDATA calldata_sol = state . solver . eval_memory ( state . calldata , length = BVV ( 68 , 256 ), raw = True ) # Get a solution for CALLVALUE (i.e., how much we paid for a penguin) # (Note: Yices2 does not expose a min() function, but you can find the minimum value # by using a bisection search) callvalue = state . solver . eval ( state . ctx [ 'CALLVALUE' ]) print ( f \" \ud83d\udce5 Calldata: { hex ( bv_unsigned_value ( calldata_sol )) } \" ) print ( f \" \ud83d\udcb8 Callvalue: { callvalue } \" ) break elif len ( simgr . found ) == 0 : print ( f \" \u274c No state found for { stop_stmt . __internal_name__ } at { stop_stmt . id } !\" ) break if __name__ == \"__main__\" : main ()","title":"(2) Mint a PudgyPenguin"},{"location":"faq/","text":"\uff1fFAQ Why is it named greed? We all know why people are so interested in finding vulnerabilities in smart contracts..., right? \ud83d\ude09 How should \"greed\" be stylized? Simple: greed , no upper case. Why didn't you just implement everything on top of angr? While implementing everything on top of angr could have been an option, some of the fundamentals of EVM analysis are quite different compared to classic binaries (ARM, x86, AMD64). Moreover, we wanted to re-use the high-quality analyses (e.g., CFG) and IR offered by Gigahorse. Thus, starting from square one was simpler than fighting with the angr codebase. Why did you choose to build a symbolic executor on TAC? We believe that register-based analyses are more intuitive and straightforward to implement: Gigahorse gets rid of the unnecessary complexity related to the stack-based nature of the EVM, thus really improving the usability of greed. Having a common intermediate representation is also valuable since, as the Dedaub team adds support for new non-EVM-based architectures, greed will automatically support such architectures. \ud83d\ude42 How do I know the correspondence between TAC statements and original opcodes? Gigahorse outputs a file called TAC_Statement_OriginalStatement.csv . While this is not always 100% precise, you can find the correspondence between the TAC Statement ID and the original PC (bytecode) there. Does greed support non-EVM contracts? greed automatically supports anything that Gigahorse supports. Currently, Gigahorse does not support any non-EVM binary. Thus, currently, greed does not support any non-EVM binary. Can greed work with contract source code? Yes. Just compile the contract and decompile it with Gigahorse, et voila! Does greed work with Vyper contracts? Yes. Just compile the contract and decompile it with Gigahorse, et voila! \ud83d\ude09 What is the main difference between greed and Mythril? While Mythril is a symbolic analysis tool for detecting specific vulnerabilities in smart contracts, greed is a more flexible analysis framework that lets you build any analysis on top of the high-quality results offered by Gigahorse. Note that any of the analyses in Mythril can be re-implemented on top of greed, but the opposite is not always possible. What is the main difference between greed and teEther? First, teEther is a symbolic executor built on the stack-based EVM opcodes, but greed builds on the register-based TAC IR. We have also found teEther's CFG reconstruction quite outdated when used against modern contracts. We believe greed offers a more flexible and robust design for building efficient research prototypes. What is the main difference between greed and ETHBMC? Similar to teEther, ETHBMC builds on the stack-based EVM opcodes. We found hacking into ETHBMC quite cumbersome compared to the Python-based greed APIs. One could argue that a Rust backend (ETHBMC) has to be faster than greed (Python), but in our experience, greed offers a more user-friendly Python API and better performance \u2013 also thanks to some careful optimizations such as our caching layers. Why is my symbolic execution stuck?! Symbolic execution is not easy, and many moving pieces are involved to make this work. If your script is stuck, it is likely because (1) there are too many states (i.e., state explosion) or (2) the constraints have become so complex that even state-of-the-art solvers cannot do much to solve them. Two excellent strategies to succeed with symbolic execution are (1) directing the execution by pruning some states and (2) concretizing as many values as possible. In other words, hoping to \"just symbolically execute\" a contract and enumerate all vulnerabilities is generally a lost cause. I have a problem. How can I get in touch with the greed developers? Just open an issue on our GitHub! \ud83d\ude42","title":"FAQ"},{"location":"faq/#faq","text":"","title":"\uff1fFAQ"},{"location":"faq/#why-is-it-named-greed","text":"We all know why people are so interested in finding vulnerabilities in smart contracts..., right? \ud83d\ude09","title":"Why is it named greed?"},{"location":"faq/#how-should-greed-be-stylized","text":"Simple: greed , no upper case.","title":"How should \"greed\" be stylized?"},{"location":"faq/#why-didnt-you-just-implement-everything-on-top-of-angr","text":"While implementing everything on top of angr could have been an option, some of the fundamentals of EVM analysis are quite different compared to classic binaries (ARM, x86, AMD64). Moreover, we wanted to re-use the high-quality analyses (e.g., CFG) and IR offered by Gigahorse. Thus, starting from square one was simpler than fighting with the angr codebase.","title":"Why didn't you just implement everything on top of angr?"},{"location":"faq/#why-did-you-choose-to-build-a-symbolic-executor-on-tac","text":"We believe that register-based analyses are more intuitive and straightforward to implement: Gigahorse gets rid of the unnecessary complexity related to the stack-based nature of the EVM, thus really improving the usability of greed. Having a common intermediate representation is also valuable since, as the Dedaub team adds support for new non-EVM-based architectures, greed will automatically support such architectures. \ud83d\ude42","title":"Why did you choose to build a symbolic executor on TAC?"},{"location":"faq/#how-do-i-know-the-correspondence-between-tac-statements-and-original-opcodes","text":"Gigahorse outputs a file called TAC_Statement_OriginalStatement.csv . While this is not always 100% precise, you can find the correspondence between the TAC Statement ID and the original PC (bytecode) there.","title":"How do I know the correspondence between TAC statements and original opcodes?"},{"location":"faq/#does-greed-support-non-evm-contracts","text":"greed automatically supports anything that Gigahorse supports. Currently, Gigahorse does not support any non-EVM binary. Thus, currently, greed does not support any non-EVM binary.","title":"Does greed support non-EVM contracts?"},{"location":"faq/#can-greed-work-with-contract-source-code","text":"Yes. Just compile the contract and decompile it with Gigahorse, et voila!","title":"Can greed work with contract source code?"},{"location":"faq/#does-greed-work-with-vyper-contracts","text":"Yes. Just compile the contract and decompile it with Gigahorse, et voila! \ud83d\ude09","title":"Does greed work with Vyper contracts?"},{"location":"faq/#what-is-the-main-difference-between-greed-and-mythril","text":"While Mythril is a symbolic analysis tool for detecting specific vulnerabilities in smart contracts, greed is a more flexible analysis framework that lets you build any analysis on top of the high-quality results offered by Gigahorse. Note that any of the analyses in Mythril can be re-implemented on top of greed, but the opposite is not always possible.","title":"What is the main difference between greed and Mythril?"},{"location":"faq/#what-is-the-main-difference-between-greed-and-teether","text":"First, teEther is a symbolic executor built on the stack-based EVM opcodes, but greed builds on the register-based TAC IR. We have also found teEther's CFG reconstruction quite outdated when used against modern contracts. We believe greed offers a more flexible and robust design for building efficient research prototypes.","title":"What is the main difference between greed and teEther?"},{"location":"faq/#what-is-the-main-difference-between-greed-and-ethbmc","text":"Similar to teEther, ETHBMC builds on the stack-based EVM opcodes. We found hacking into ETHBMC quite cumbersome compared to the Python-based greed APIs. One could argue that a Rust backend (ETHBMC) has to be faster than greed (Python), but in our experience, greed offers a more user-friendly Python API and better performance \u2013 also thanks to some careful optimizations such as our caching layers.","title":"What is the main difference between greed and ETHBMC?"},{"location":"faq/#why-is-my-symbolic-execution-stuck","text":"Symbolic execution is not easy, and many moving pieces are involved to make this work. If your script is stuck, it is likely because (1) there are too many states (i.e., state explosion) or (2) the constraints have become so complex that even state-of-the-art solvers cannot do much to solve them. Two excellent strategies to succeed with symbolic execution are (1) directing the execution by pruning some states and (2) concretizing as many values as possible. In other words, hoping to \"just symbolically execute\" a contract and enumerate all vulnerabilities is generally a lost cause.","title":"Why is my symbolic execution stuck?!"},{"location":"faq/#i-have-a-problem-how-can-i-get-in-touch-with-the-greed-developers","text":"Just open an issue on our GitHub! \ud83d\ude42","title":"I have a problem. How can I get in touch with the greed developers?"},{"location":"options/","text":"\ud83d\udd79\ufe0f Options greed supports many options to tweak the behavior of symbolic execution. Global Options These options are global and impact all the states generated during symbolic execution: Option Name Default Description WEB3_PROVIDER http://0.0.0.0:8545 Web3 provider URI. Used when initializing the partial concrete storage. LAZY_SOLVES False Indicates whether to check for satisfiability at every fork, affecting exploration speed and state pruning. GREEDY_SHA False Specifies whether to calculate SHA3 for concrete or single-solution buffers, potentially impacting exploration speed. SIMGRVIZ False Activates the creation of a graph visualizing the exploration (the SimgrViz Exploration Technique must also be installed) MAX_CALLDATA_SIZE 256 Default CALLDATASIZE considered, can be overwritten by the entry_state constructor. MATH_CONCRETIZE_SYMBOLIC_EXP_EXP False Specifies whether to concretize the exponent of an EXP instruction. MATH_CONCRETIZE_SYMBOLIC_EXP_BASE False Specifies whether to concretize the base of an EXP instruction. MATH_MULTIPLY_EXP_THRESHOLD 10 Maximum supported nested multiplications when encountering a symbolic base with a concrete exponent. OPTIMISTIC_CALL_RESULTS False Indicates whether always to consider CALLS succeeded. DEFAULT_EXTCODESIZE False Specifies whether to use a default constant value for EXTCODESIZE. DEFAULT_CREATE_RESULT_ADDRESS False Specifies whether to use a default constant address when using the CREATE opcode. DEFAULT_CREATE2_RESULT_ADDRESS False Specifies whether to use a default constant address when using the CREATE2 opcode. STATE_STOP_AT_ADDCONSTRAINT False Indicates whether to drop a debugging interface whenever a constraint is added to the state. MAX_SHA_SIZE 512 Maximum considered size for the SHA3 input buffer. SOLVER \"YICES2\" Default solver (Yices2). SOLVER_TIMEOUT Inf. Timeout setting for the solver. State Options These options can be activated/deactivated per single state: Option Name Default Description STATE_INSPECT False Activates debugging capabilities through the SimStateInspect plugin (i.e., breakpoints).","title":"Options"},{"location":"options/#options","text":"greed supports many options to tweak the behavior of symbolic execution.","title":"\ud83d\udd79\ufe0f Options"},{"location":"options/#global-options","text":"These options are global and impact all the states generated during symbolic execution: Option Name Default Description WEB3_PROVIDER http://0.0.0.0:8545 Web3 provider URI. Used when initializing the partial concrete storage. LAZY_SOLVES False Indicates whether to check for satisfiability at every fork, affecting exploration speed and state pruning. GREEDY_SHA False Specifies whether to calculate SHA3 for concrete or single-solution buffers, potentially impacting exploration speed. SIMGRVIZ False Activates the creation of a graph visualizing the exploration (the SimgrViz Exploration Technique must also be installed) MAX_CALLDATA_SIZE 256 Default CALLDATASIZE considered, can be overwritten by the entry_state constructor. MATH_CONCRETIZE_SYMBOLIC_EXP_EXP False Specifies whether to concretize the exponent of an EXP instruction. MATH_CONCRETIZE_SYMBOLIC_EXP_BASE False Specifies whether to concretize the base of an EXP instruction. MATH_MULTIPLY_EXP_THRESHOLD 10 Maximum supported nested multiplications when encountering a symbolic base with a concrete exponent. OPTIMISTIC_CALL_RESULTS False Indicates whether always to consider CALLS succeeded. DEFAULT_EXTCODESIZE False Specifies whether to use a default constant value for EXTCODESIZE. DEFAULT_CREATE_RESULT_ADDRESS False Specifies whether to use a default constant address when using the CREATE opcode. DEFAULT_CREATE2_RESULT_ADDRESS False Specifies whether to use a default constant address when using the CREATE2 opcode. STATE_STOP_AT_ADDCONSTRAINT False Indicates whether to drop a debugging interface whenever a constraint is added to the state. MAX_SHA_SIZE 512 Maximum considered size for the SHA3 input buffer. SOLVER \"YICES2\" Default solver (Yices2). SOLVER_TIMEOUT Inf. Timeout setting for the solver.","title":"Global Options"},{"location":"options/#state-options","text":"These options can be activated/deactivated per single state: Option Name Default Description STATE_INSPECT False Activates debugging capabilities through the SimStateInspect plugin (i.e., breakpoints).","title":"State Options"},{"location":"quickstart/","text":"\u26a1\ufe0f Quick Start Installing from Source Tip \u2b50\ufe0f We strongly suggest using a python virtual environment rather than installing greed globally. Doing so reduces dependency conflicts and aids in reproducibility while debugging. Some popular tools that accomplish this include virtualenv and virtualenvwrapper . git clone git@github.com:ucsb-seclab/greed.git mkvirtualenv greed workon greed ./setup.sh Usage First, the contract needs to be pre-processed with gigahorse. This can be done in two ways: # Create a new folder. The analyses will pollute the current working directory mkdir /tmp/test_contract cd /tmp/test_contract/ # OPTION 1: From the solidity source cp <contract_source> contract.sol analyze_source.sh contract.sol # OPTION 2: From the contract bytecode cp <contract_bytecode> contract.hex analyze_hex.sh contract.hex You can find the scripts analyze_source.sh and analyze_hex.sh in /greed/resources . Then, to use greed in your python project: from greed import Project p = Project ( target_dir = \"/tmp/test_contract/\" ) entry_state = p . factory . entry_state ( xid = 0 ) simgr = p . factory . simgr ( entry_state = entry_state ) simgr . run () Or to run greed from the command line: greed /tmp/test_contract [ --debug ] [ --find <address> ] Reporting Bugs \ud83e\udeb3 Please report any bugs through the Issue section on our GitHub! If you can provide a POC for your issue it would greatly speed up the resolution of your problem :)","title":"QuickStart"},{"location":"quickstart/#quick-start","text":"","title":"\u26a1\ufe0f Quick Start"},{"location":"quickstart/#installing-from-source","text":"Tip \u2b50\ufe0f We strongly suggest using a python virtual environment rather than installing greed globally. Doing so reduces dependency conflicts and aids in reproducibility while debugging. Some popular tools that accomplish this include virtualenv and virtualenvwrapper . git clone git@github.com:ucsb-seclab/greed.git mkvirtualenv greed workon greed ./setup.sh","title":"Installing from Source"},{"location":"quickstart/#usage","text":"First, the contract needs to be pre-processed with gigahorse. This can be done in two ways: # Create a new folder. The analyses will pollute the current working directory mkdir /tmp/test_contract cd /tmp/test_contract/ # OPTION 1: From the solidity source cp <contract_source> contract.sol analyze_source.sh contract.sol # OPTION 2: From the contract bytecode cp <contract_bytecode> contract.hex analyze_hex.sh contract.hex You can find the scripts analyze_source.sh and analyze_hex.sh in /greed/resources . Then, to use greed in your python project: from greed import Project p = Project ( target_dir = \"/tmp/test_contract/\" ) entry_state = p . factory . entry_state ( xid = 0 ) simgr = p . factory . simgr ( entry_state = entry_state ) simgr . run () Or to run greed from the command line: greed /tmp/test_contract [ --debug ] [ --find <address> ]","title":"Usage"},{"location":"quickstart/#reporting-bugs","text":"Please report any bugs through the Issue section on our GitHub! If you can provide a POC for your issue it would greatly speed up the resolution of your problem :)","title":"Reporting Bugs \ud83e\udeb3"},{"location":"modules/greed.TAC.TAC_parser/","text":"module greed.TAC.TAC_parser Global Variables tac_opcode_to_class_map class TAC_parser This class parses the TAC facts generated by Gigahorse and builds the CFG. method __init__ __init__ ( factory : Factory , target_dir : str ) method parse_abi parse_abi () method parse_blocks parse_blocks () method parse_blocks_in_loop parse_blocks_in_loop () method parse_functions parse_functions () method parse_guarded_slots parse_guarded_slots ( guarding_slots , sstores_for_slot ) method parse_guarding_slots parse_guarding_slots () method parse_induction_variable_increases_by_const parse_induction_variable_increases_by_const () method parse_induction_variable_starts_at_const parse_induction_variable_starts_at_const () method parse_induction_variable_upper_bounds parse_induction_variable_upper_bounds () method parse_induction_variables parse_induction_variables () method parse_recovered_abi parse_recovered_abi () method parse_statements parse_statements () method stmt_sort_key stmt_sort_key ( stmt_id : str ) \u2192 int This file was automatically generated via lazydocs .","title":"greed.TAC.TAC_parser"},{"location":"modules/greed.TAC.TAC_parser/#module-greedtactac_parser","text":"","title":"module greed.TAC.TAC_parser"},{"location":"modules/greed.TAC.TAC_parser/#global-variables","text":"tac_opcode_to_class_map","title":"Global Variables"},{"location":"modules/greed.TAC.TAC_parser/#class-tac_parser","text":"This class parses the TAC facts generated by Gigahorse and builds the CFG.","title":"class TAC_parser"},{"location":"modules/greed.TAC.TAC_parser/#method-__init__","text":"__init__ ( factory : Factory , target_dir : str )","title":"method __init__"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_abi","text":"parse_abi ()","title":"method parse_abi"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_blocks","text":"parse_blocks ()","title":"method parse_blocks"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_blocks_in_loop","text":"parse_blocks_in_loop ()","title":"method parse_blocks_in_loop"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_functions","text":"parse_functions ()","title":"method parse_functions"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_guarded_slots","text":"parse_guarded_slots ( guarding_slots , sstores_for_slot )","title":"method parse_guarded_slots"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_guarding_slots","text":"parse_guarding_slots ()","title":"method parse_guarding_slots"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_induction_variable_increases_by_const","text":"parse_induction_variable_increases_by_const ()","title":"method parse_induction_variable_increases_by_const"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_induction_variable_starts_at_const","text":"parse_induction_variable_starts_at_const ()","title":"method parse_induction_variable_starts_at_const"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_induction_variable_upper_bounds","text":"parse_induction_variable_upper_bounds ()","title":"method parse_induction_variable_upper_bounds"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_induction_variables","text":"parse_induction_variables ()","title":"method parse_induction_variables"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_recovered_abi","text":"parse_recovered_abi ()","title":"method parse_recovered_abi"},{"location":"modules/greed.TAC.TAC_parser/#method-parse_statements","text":"parse_statements ()","title":"method parse_statements"},{"location":"modules/greed.TAC.TAC_parser/#method-stmt_sort_key","text":"stmt_sort_key ( stmt_id : str ) \u2192 int This file was automatically generated via lazydocs .","title":"method stmt_sort_key"},{"location":"modules/greed.TAC.base/","text":"module greed.TAC.base class Aliased This class allows us to use aliases for the attributes of a class. For example, if we have a class with the following attributes: ['a', 'b', 'c'], we can define a dictionary aliases = {'x': 'a', 'y': 'b'} and then access the attributes of the class using the aliases. class TAC_Statement This class represents a TAC Statement. method __init__ __init__ ( block_id : str , stmt_id : str , uses : List [ str ] = None , defs : List [ str ] = None , values : Mapping [ str , str ] = None ) Args: block_id : The id of the block that contains this statement. stmt_id : The id of this statement. uses : The list of variables used by this statement. defs : The list of variables defined by this statement. values : The static values of the variables used by this statement. method copy copy ( alias_arg_map = None ) method handler_with_side_effects handler_with_side_effects ( func : Callable [[ ForwardRef ( 'TAC_Statement' ), SymbolicEVMState ], List [ SymbolicEVMState ]] ) Decorator that executes the basic functionalities for handlers with side effects (can't just read and return statically computed results). method handler_without_side_effects handler_without_side_effects ( func : Callable [[ ForwardRef ( 'TAC_Statement' ), SymbolicEVMState ], List [ SymbolicEVMState ]] ) Decorator that executes the basic functionalities for handlers without side effects (can just read and return statically computed results). method process_args process_args () method reset_arg_val reset_arg_val () method set_arg_val set_arg_val ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"greed.TAC.base"},{"location":"modules/greed.TAC.base/#module-greedtacbase","text":"","title":"module greed.TAC.base"},{"location":"modules/greed.TAC.base/#class-aliased","text":"This class allows us to use aliases for the attributes of a class. For example, if we have a class with the following attributes: ['a', 'b', 'c'], we can define a dictionary aliases = {'x': 'a', 'y': 'b'} and then access the attributes of the class using the aliases.","title":"class Aliased"},{"location":"modules/greed.TAC.base/#class-tac_statement","text":"This class represents a TAC Statement.","title":"class TAC_Statement"},{"location":"modules/greed.TAC.base/#method-__init__","text":"__init__ ( block_id : str , stmt_id : str , uses : List [ str ] = None , defs : List [ str ] = None , values : Mapping [ str , str ] = None ) Args: block_id : The id of the block that contains this statement. stmt_id : The id of this statement. uses : The list of variables used by this statement. defs : The list of variables defined by this statement. values : The static values of the variables used by this statement.","title":"method __init__"},{"location":"modules/greed.TAC.base/#method-copy","text":"copy ( alias_arg_map = None )","title":"method copy"},{"location":"modules/greed.TAC.base/#method-handler_with_side_effects","text":"handler_with_side_effects ( func : Callable [[ ForwardRef ( 'TAC_Statement' ), SymbolicEVMState ], List [ SymbolicEVMState ]] ) Decorator that executes the basic functionalities for handlers with side effects (can't just read and return statically computed results).","title":"method handler_with_side_effects"},{"location":"modules/greed.TAC.base/#method-handler_without_side_effects","text":"handler_without_side_effects ( func : Callable [[ ForwardRef ( 'TAC_Statement' ), SymbolicEVMState ], List [ SymbolicEVMState ]] ) Decorator that executes the basic functionalities for handlers without side effects (can just read and return statically computed results).","title":"method handler_without_side_effects"},{"location":"modules/greed.TAC.base/#method-process_args","text":"process_args ()","title":"method process_args"},{"location":"modules/greed.TAC.base/#method-reset_arg_val","text":"reset_arg_val ()","title":"method reset_arg_val"},{"location":"modules/greed.TAC.base/#method-set_arg_val","text":"set_arg_val ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"method set_arg_val"},{"location":"modules/greed.TAC.flow_ops/","text":"module greed.TAC.flow_ops class TAC_Jump This class represents a JUMP TAC statement. method handle handle ( state : SymbolicEVMState ) class TAC_Jumpi method handle handle ( state : SymbolicEVMState ) class TAC_BaseCall This class represents super class for all CALL TAC statements. method set_likeyl_known_target_func set_likeyl_known_target_func ( target_function ) class TAC_Call method handle handle ( state : SymbolicEVMState ) method set_likeyl_known_target_func set_likeyl_known_target_func ( target_function ) class TAC_Callcode method handle handle ( state : SymbolicEVMState ) method set_likeyl_known_target_func set_likeyl_known_target_func ( target_function ) class TAC_Delegatecall method handle handle ( state : SymbolicEVMState ) method set_likeyl_known_target_func set_likeyl_known_target_func ( target_function ) class TAC_Staticcall method handle handle ( state : SymbolicEVMState ) method set_likeyl_known_target_func set_likeyl_known_target_func ( target_function ) This file was automatically generated via lazydocs .","title":"greed.TAC.flow_ops"},{"location":"modules/greed.TAC.flow_ops/#module-greedtacflow_ops","text":"","title":"module greed.TAC.flow_ops"},{"location":"modules/greed.TAC.flow_ops/#class-tac_jump","text":"This class represents a JUMP TAC statement.","title":"class TAC_Jump"},{"location":"modules/greed.TAC.flow_ops/#method-handle","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.flow_ops/#class-tac_jumpi","text":"","title":"class TAC_Jumpi"},{"location":"modules/greed.TAC.flow_ops/#method-handle_1","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.flow_ops/#class-tac_basecall","text":"This class represents super class for all CALL TAC statements.","title":"class TAC_BaseCall"},{"location":"modules/greed.TAC.flow_ops/#method-set_likeyl_known_target_func","text":"set_likeyl_known_target_func ( target_function )","title":"method set_likeyl_known_target_func"},{"location":"modules/greed.TAC.flow_ops/#class-tac_call","text":"","title":"class TAC_Call"},{"location":"modules/greed.TAC.flow_ops/#method-handle_2","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.flow_ops/#method-set_likeyl_known_target_func_1","text":"set_likeyl_known_target_func ( target_function )","title":"method set_likeyl_known_target_func"},{"location":"modules/greed.TAC.flow_ops/#class-tac_callcode","text":"","title":"class TAC_Callcode"},{"location":"modules/greed.TAC.flow_ops/#method-handle_3","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.flow_ops/#method-set_likeyl_known_target_func_2","text":"set_likeyl_known_target_func ( target_function )","title":"method set_likeyl_known_target_func"},{"location":"modules/greed.TAC.flow_ops/#class-tac_delegatecall","text":"","title":"class TAC_Delegatecall"},{"location":"modules/greed.TAC.flow_ops/#method-handle_4","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.flow_ops/#method-set_likeyl_known_target_func_3","text":"set_likeyl_known_target_func ( target_function )","title":"method set_likeyl_known_target_func"},{"location":"modules/greed.TAC.flow_ops/#class-tac_staticcall","text":"","title":"class TAC_Staticcall"},{"location":"modules/greed.TAC.flow_ops/#method-handle_5","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.flow_ops/#method-set_likeyl_known_target_func_4","text":"set_likeyl_known_target_func ( target_function ) This file was automatically generated via lazydocs .","title":"method set_likeyl_known_target_func"},{"location":"modules/greed.TAC.gigahorse_ops/","text":"module greed.TAC.gigahorse_ops class TAC_Throw method handle handle ( state : SymbolicEVMState ) class TAC_Callprivate method handle handle ( state : SymbolicEVMState ) class TAC_Returnprivate method handle handle ( state : SymbolicEVMState ) class TAC_Phi method handle handle ( state : SymbolicEVMState ) class TAC_Const method handle handle ( state : SymbolicEVMState ) class TAC_Nop method handle handle ( state : SymbolicEVMState ) class TAC_Callprivateargs method handle handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"greed.TAC.gigahorse_ops"},{"location":"modules/greed.TAC.gigahorse_ops/#module-greedtacgigahorse_ops","text":"","title":"module greed.TAC.gigahorse_ops"},{"location":"modules/greed.TAC.gigahorse_ops/#class-tac_throw","text":"","title":"class TAC_Throw"},{"location":"modules/greed.TAC.gigahorse_ops/#method-handle","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.gigahorse_ops/#class-tac_callprivate","text":"","title":"class TAC_Callprivate"},{"location":"modules/greed.TAC.gigahorse_ops/#method-handle_1","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.gigahorse_ops/#class-tac_returnprivate","text":"","title":"class TAC_Returnprivate"},{"location":"modules/greed.TAC.gigahorse_ops/#method-handle_2","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.gigahorse_ops/#class-tac_phi","text":"","title":"class TAC_Phi"},{"location":"modules/greed.TAC.gigahorse_ops/#method-handle_3","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.gigahorse_ops/#class-tac_const","text":"","title":"class TAC_Const"},{"location":"modules/greed.TAC.gigahorse_ops/#method-handle_4","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.gigahorse_ops/#class-tac_nop","text":"","title":"class TAC_Nop"},{"location":"modules/greed.TAC.gigahorse_ops/#method-handle_5","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.gigahorse_ops/#class-tac_callprivateargs","text":"","title":"class TAC_Callprivateargs"},{"location":"modules/greed.TAC.gigahorse_ops/#method-handle_6","text":"handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"method handle"},{"location":"modules/greed.TAC.log_ops/","text":"module greed.TAC.log_ops class TAC_Log method handle handle ( state : SymbolicEVMState ) class TAC_Log0 method handle handle ( state : SymbolicEVMState ) class TAC_Log1 method handle handle ( state : SymbolicEVMState ) class TAC_Log2 method handle handle ( state : SymbolicEVMState ) class TAC_Log3 method handle handle ( state : SymbolicEVMState ) class TAC_Log4 method handle handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"greed.TAC.log_ops"},{"location":"modules/greed.TAC.log_ops/#module-greedtaclog_ops","text":"","title":"module greed.TAC.log_ops"},{"location":"modules/greed.TAC.log_ops/#class-tac_log","text":"","title":"class TAC_Log"},{"location":"modules/greed.TAC.log_ops/#method-handle","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.log_ops/#class-tac_log0","text":"","title":"class TAC_Log0"},{"location":"modules/greed.TAC.log_ops/#method-handle_1","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.log_ops/#class-tac_log1","text":"","title":"class TAC_Log1"},{"location":"modules/greed.TAC.log_ops/#method-handle_2","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.log_ops/#class-tac_log2","text":"","title":"class TAC_Log2"},{"location":"modules/greed.TAC.log_ops/#method-handle_3","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.log_ops/#class-tac_log3","text":"","title":"class TAC_Log3"},{"location":"modules/greed.TAC.log_ops/#method-handle_4","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.log_ops/#class-tac_log4","text":"","title":"class TAC_Log4"},{"location":"modules/greed.TAC.log_ops/#method-handle_5","text":"handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"method handle"},{"location":"modules/greed.TAC.math_ops/","text":"module greed.TAC.math_ops class TAC_Add method handle handle ( state : SymbolicEVMState ) class TAC_Sub method handle handle ( state : SymbolicEVMState ) class TAC_Mul method handle handle ( state : SymbolicEVMState ) class TAC_Div method handle handle ( state : SymbolicEVMState ) class TAC_Sdiv method handle handle ( state : SymbolicEVMState ) class TAC_Mod method handle handle ( state : SymbolicEVMState ) class TAC_Smod method handle handle ( state : SymbolicEVMState ) class TAC_Addmod method handle handle ( state : SymbolicEVMState ) class TAC_Mulmod method handle handle ( state : SymbolicEVMState ) class TAC_Exp method handle handle ( state : SymbolicEVMState ) class TAC_Signextend method handle handle ( state : SymbolicEVMState ) class TAC_Lt method handle handle ( state : SymbolicEVMState ) class TAC_Gt method handle handle ( state : SymbolicEVMState ) class TAC_Slt method handle handle ( state : SymbolicEVMState ) class TAC_Sgt method handle handle ( state : SymbolicEVMState ) class TAC_Eq method handle handle ( state : SymbolicEVMState ) class TAC_Iszero method handle handle ( state : SymbolicEVMState ) class TAC_And method handle handle ( state : SymbolicEVMState ) class TAC_Or method handle handle ( state : SymbolicEVMState ) class TAC_Xor method handle handle ( state : SymbolicEVMState ) class TAC_Not method handle handle ( state : SymbolicEVMState ) class TAC_Byte method handle handle ( state : SymbolicEVMState ) class TAC_Shl method handle handle ( state : SymbolicEVMState ) class TAC_Shr method handle handle ( state : SymbolicEVMState ) class TAC_Sar method handle handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"greed.TAC.math_ops"},{"location":"modules/greed.TAC.math_ops/#module-greedtacmath_ops","text":"","title":"module greed.TAC.math_ops"},{"location":"modules/greed.TAC.math_ops/#class-tac_add","text":"","title":"class TAC_Add"},{"location":"modules/greed.TAC.math_ops/#method-handle","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_sub","text":"","title":"class TAC_Sub"},{"location":"modules/greed.TAC.math_ops/#method-handle_1","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_mul","text":"","title":"class TAC_Mul"},{"location":"modules/greed.TAC.math_ops/#method-handle_2","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_div","text":"","title":"class TAC_Div"},{"location":"modules/greed.TAC.math_ops/#method-handle_3","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_sdiv","text":"","title":"class TAC_Sdiv"},{"location":"modules/greed.TAC.math_ops/#method-handle_4","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_mod","text":"","title":"class TAC_Mod"},{"location":"modules/greed.TAC.math_ops/#method-handle_5","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_smod","text":"","title":"class TAC_Smod"},{"location":"modules/greed.TAC.math_ops/#method-handle_6","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_addmod","text":"","title":"class TAC_Addmod"},{"location":"modules/greed.TAC.math_ops/#method-handle_7","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_mulmod","text":"","title":"class TAC_Mulmod"},{"location":"modules/greed.TAC.math_ops/#method-handle_8","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_exp","text":"","title":"class TAC_Exp"},{"location":"modules/greed.TAC.math_ops/#method-handle_9","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_signextend","text":"","title":"class TAC_Signextend"},{"location":"modules/greed.TAC.math_ops/#method-handle_10","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_lt","text":"","title":"class TAC_Lt"},{"location":"modules/greed.TAC.math_ops/#method-handle_11","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_gt","text":"","title":"class TAC_Gt"},{"location":"modules/greed.TAC.math_ops/#method-handle_12","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_slt","text":"","title":"class TAC_Slt"},{"location":"modules/greed.TAC.math_ops/#method-handle_13","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_sgt","text":"","title":"class TAC_Sgt"},{"location":"modules/greed.TAC.math_ops/#method-handle_14","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_eq","text":"","title":"class TAC_Eq"},{"location":"modules/greed.TAC.math_ops/#method-handle_15","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_iszero","text":"","title":"class TAC_Iszero"},{"location":"modules/greed.TAC.math_ops/#method-handle_16","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_and","text":"","title":"class TAC_And"},{"location":"modules/greed.TAC.math_ops/#method-handle_17","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_or","text":"","title":"class TAC_Or"},{"location":"modules/greed.TAC.math_ops/#method-handle_18","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_xor","text":"","title":"class TAC_Xor"},{"location":"modules/greed.TAC.math_ops/#method-handle_19","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_not","text":"","title":"class TAC_Not"},{"location":"modules/greed.TAC.math_ops/#method-handle_20","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_byte","text":"","title":"class TAC_Byte"},{"location":"modules/greed.TAC.math_ops/#method-handle_21","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_shl","text":"","title":"class TAC_Shl"},{"location":"modules/greed.TAC.math_ops/#method-handle_22","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_shr","text":"","title":"class TAC_Shr"},{"location":"modules/greed.TAC.math_ops/#method-handle_23","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.math_ops/#class-tac_sar","text":"","title":"class TAC_Sar"},{"location":"modules/greed.TAC.math_ops/#method-handle_24","text":"handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"method handle"},{"location":"modules/greed.TAC.mem_ops/","text":"module greed.TAC.mem_ops class TAC_Mstore method handle handle ( state : SymbolicEVMState ) class TAC_Mstore8 method handle handle ( state : SymbolicEVMState ) class TAC_Mload method handle handle ( state : SymbolicEVMState ) class TAC_Sload method handle handle ( state : SymbolicEVMState ) class TAC_Sstore method handle handle ( state : SymbolicEVMState ) class TAC_Msize method handle handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"greed.TAC.mem_ops"},{"location":"modules/greed.TAC.mem_ops/#module-greedtacmem_ops","text":"","title":"module greed.TAC.mem_ops"},{"location":"modules/greed.TAC.mem_ops/#class-tac_mstore","text":"","title":"class TAC_Mstore"},{"location":"modules/greed.TAC.mem_ops/#method-handle","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.mem_ops/#class-tac_mstore8","text":"","title":"class TAC_Mstore8"},{"location":"modules/greed.TAC.mem_ops/#method-handle_1","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.mem_ops/#class-tac_mload","text":"","title":"class TAC_Mload"},{"location":"modules/greed.TAC.mem_ops/#method-handle_2","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.mem_ops/#class-tac_sload","text":"","title":"class TAC_Sload"},{"location":"modules/greed.TAC.mem_ops/#method-handle_3","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.mem_ops/#class-tac_sstore","text":"","title":"class TAC_Sstore"},{"location":"modules/greed.TAC.mem_ops/#method-handle_4","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.mem_ops/#class-tac_msize","text":"","title":"class TAC_Msize"},{"location":"modules/greed.TAC.mem_ops/#method-handle_5","text":"handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"method handle"},{"location":"modules/greed.TAC.special_ops/","text":"module greed.TAC.special_ops class TAC_Sha3 method handle handle ( state : SymbolicEVMState ) class TAC_Stop method handle handle ( state : SymbolicEVMState ) class TAC_Address method handle handle ( state : SymbolicEVMState ) class TAC_Balance method handle handle ( state : SymbolicEVMState ) class TAC_Origin method handle handle ( state : SymbolicEVMState ) class TAC_Caller method handle handle ( state : SymbolicEVMState ) class TAC_Callvalue method handle handle ( state : SymbolicEVMState ) class TAC_Calldataload method handle handle ( state : SymbolicEVMState ) class TAC_Calldatasize method handle handle ( state : SymbolicEVMState ) class TAC_Calldatacopy method handle handle ( state : SymbolicEVMState ) class TAC_Codesize method handle handle ( state : SymbolicEVMState ) class TAC_Codecopy method handle handle ( state : SymbolicEVMState ) class TAC_Gasprice method handle handle ( state : SymbolicEVMState ) class TAC_Extcodesize method handle handle ( state : SymbolicEVMState ) class TAC_Extcodecopy method handle handle ( state : SymbolicEVMState ) class TAC_Returndatasize method handle handle ( state : SymbolicEVMState ) class TAC_Returndatacopy method handle handle ( state : SymbolicEVMState ) class TAC_Extcodehash method handle handle ( state : SymbolicEVMState ) class TAC_Blockhash method handle handle ( state : SymbolicEVMState ) class TAC_Coinbase method handle handle ( state : SymbolicEVMState ) class TAC_Timestamp method handle handle ( state : SymbolicEVMState ) class TAC_Number method handle handle ( state : SymbolicEVMState ) class TAC_Difficulty method handle handle ( state : SymbolicEVMState ) class TAC_Gaslimit method handle handle ( state : SymbolicEVMState ) class TAC_Chainid method handle handle ( state : SymbolicEVMState ) class TAC_Selfbalance method handle handle ( state : SymbolicEVMState ) class TAC_Basefee method handle handle ( state : SymbolicEVMState ) class TAC_Return method handle handle ( state : SymbolicEVMState ) class TAC_Revert method handle handle ( state : SymbolicEVMState ) class TAC_Create method handle handle ( state : SymbolicEVMState ) class TAC_Create2 method handle handle ( state : SymbolicEVMState ) class TAC_Pc method handle handle ( state : SymbolicEVMState ) class TAC_Invalid method handle handle ( state : SymbolicEVMState ) class TAC_Selfdestruct method handle handle ( state : SymbolicEVMState ) class TAC_Gas method handle handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"greed.TAC.special_ops"},{"location":"modules/greed.TAC.special_ops/#module-greedtacspecial_ops","text":"","title":"module greed.TAC.special_ops"},{"location":"modules/greed.TAC.special_ops/#class-tac_sha3","text":"","title":"class TAC_Sha3"},{"location":"modules/greed.TAC.special_ops/#method-handle","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_stop","text":"","title":"class TAC_Stop"},{"location":"modules/greed.TAC.special_ops/#method-handle_1","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_address","text":"","title":"class TAC_Address"},{"location":"modules/greed.TAC.special_ops/#method-handle_2","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_balance","text":"","title":"class TAC_Balance"},{"location":"modules/greed.TAC.special_ops/#method-handle_3","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_origin","text":"","title":"class TAC_Origin"},{"location":"modules/greed.TAC.special_ops/#method-handle_4","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_caller","text":"","title":"class TAC_Caller"},{"location":"modules/greed.TAC.special_ops/#method-handle_5","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_callvalue","text":"","title":"class TAC_Callvalue"},{"location":"modules/greed.TAC.special_ops/#method-handle_6","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_calldataload","text":"","title":"class TAC_Calldataload"},{"location":"modules/greed.TAC.special_ops/#method-handle_7","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_calldatasize","text":"","title":"class TAC_Calldatasize"},{"location":"modules/greed.TAC.special_ops/#method-handle_8","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_calldatacopy","text":"","title":"class TAC_Calldatacopy"},{"location":"modules/greed.TAC.special_ops/#method-handle_9","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_codesize","text":"","title":"class TAC_Codesize"},{"location":"modules/greed.TAC.special_ops/#method-handle_10","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_codecopy","text":"","title":"class TAC_Codecopy"},{"location":"modules/greed.TAC.special_ops/#method-handle_11","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_gasprice","text":"","title":"class TAC_Gasprice"},{"location":"modules/greed.TAC.special_ops/#method-handle_12","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_extcodesize","text":"","title":"class TAC_Extcodesize"},{"location":"modules/greed.TAC.special_ops/#method-handle_13","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_extcodecopy","text":"","title":"class TAC_Extcodecopy"},{"location":"modules/greed.TAC.special_ops/#method-handle_14","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_returndatasize","text":"","title":"class TAC_Returndatasize"},{"location":"modules/greed.TAC.special_ops/#method-handle_15","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_returndatacopy","text":"","title":"class TAC_Returndatacopy"},{"location":"modules/greed.TAC.special_ops/#method-handle_16","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_extcodehash","text":"","title":"class TAC_Extcodehash"},{"location":"modules/greed.TAC.special_ops/#method-handle_17","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_blockhash","text":"","title":"class TAC_Blockhash"},{"location":"modules/greed.TAC.special_ops/#method-handle_18","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_coinbase","text":"","title":"class TAC_Coinbase"},{"location":"modules/greed.TAC.special_ops/#method-handle_19","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_timestamp","text":"","title":"class TAC_Timestamp"},{"location":"modules/greed.TAC.special_ops/#method-handle_20","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_number","text":"","title":"class TAC_Number"},{"location":"modules/greed.TAC.special_ops/#method-handle_21","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_difficulty","text":"","title":"class TAC_Difficulty"},{"location":"modules/greed.TAC.special_ops/#method-handle_22","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_gaslimit","text":"","title":"class TAC_Gaslimit"},{"location":"modules/greed.TAC.special_ops/#method-handle_23","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_chainid","text":"","title":"class TAC_Chainid"},{"location":"modules/greed.TAC.special_ops/#method-handle_24","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_selfbalance","text":"","title":"class TAC_Selfbalance"},{"location":"modules/greed.TAC.special_ops/#method-handle_25","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_basefee","text":"","title":"class TAC_Basefee"},{"location":"modules/greed.TAC.special_ops/#method-handle_26","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_return","text":"","title":"class TAC_Return"},{"location":"modules/greed.TAC.special_ops/#method-handle_27","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_revert","text":"","title":"class TAC_Revert"},{"location":"modules/greed.TAC.special_ops/#method-handle_28","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_create","text":"","title":"class TAC_Create"},{"location":"modules/greed.TAC.special_ops/#method-handle_29","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_create2","text":"","title":"class TAC_Create2"},{"location":"modules/greed.TAC.special_ops/#method-handle_30","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_pc","text":"","title":"class TAC_Pc"},{"location":"modules/greed.TAC.special_ops/#method-handle_31","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_invalid","text":"","title":"class TAC_Invalid"},{"location":"modules/greed.TAC.special_ops/#method-handle_32","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_selfdestruct","text":"","title":"class TAC_Selfdestruct"},{"location":"modules/greed.TAC.special_ops/#method-handle_33","text":"handle ( state : SymbolicEVMState )","title":"method handle"},{"location":"modules/greed.TAC.special_ops/#class-tac_gas","text":"","title":"class TAC_Gas"},{"location":"modules/greed.TAC.special_ops/#method-handle_34","text":"handle ( state : SymbolicEVMState ) This file was automatically generated via lazydocs .","title":"method handle"},{"location":"modules/greed.analyses.access_control_slots/","text":"module greed.analyses.access_control_slots function dump_slice dump_slice ( full_slice , func , filename ) function get_access_control_slots get_access_control_slots ( project ) class ReverseExplorerState method __init__ __init__ ( project , func , target : str , caller = None , slices_stmts = None , slices_vars = None ) method is_stmt is_stmt () method step step () class ReverseExplorer method __init__ __init__ ( project , first_state ) method run run () This file was automatically generated via lazydocs .","title":"greed.analyses.access_control_slots"},{"location":"modules/greed.analyses.access_control_slots/#module-greedanalysesaccess_control_slots","text":"","title":"module greed.analyses.access_control_slots"},{"location":"modules/greed.analyses.access_control_slots/#function-dump_slice","text":"dump_slice ( full_slice , func , filename )","title":"function dump_slice"},{"location":"modules/greed.analyses.access_control_slots/#function-get_access_control_slots","text":"get_access_control_slots ( project )","title":"function get_access_control_slots"},{"location":"modules/greed.analyses.access_control_slots/#class-reverseexplorerstate","text":"","title":"class ReverseExplorerState"},{"location":"modules/greed.analyses.access_control_slots/#method-__init__","text":"__init__ ( project , func , target : str , caller = None , slices_stmts = None , slices_vars = None )","title":"method __init__"},{"location":"modules/greed.analyses.access_control_slots/#method-is_stmt","text":"is_stmt ()","title":"method is_stmt"},{"location":"modules/greed.analyses.access_control_slots/#method-step","text":"step ()","title":"method step"},{"location":"modules/greed.analyses.access_control_slots/#class-reverseexplorer","text":"","title":"class ReverseExplorer"},{"location":"modules/greed.analyses.access_control_slots/#method-__init___1","text":"__init__ ( project , first_state )","title":"method __init__"},{"location":"modules/greed.analyses.access_control_slots/#method-run","text":"run () This file was automatically generated via lazydocs .","title":"method run"},{"location":"modules/greed.analyses.slicing/","text":"module greed.analyses.slicing function inline_cfg inline_cfg ( p , cfg , max_rounds = 10 ) Inline max_depth levels of callprivates in the cfg, only when there is a single path in the callprivate function backward_slice backward_slice ( p , target_addr , target_vars = None , thin_slice = True ) function forward_slice forward_slice ( p , target_addr , target_vars = None , thin_slice = True ) function bidirectional_slice bidirectional_slice ( p , target_addr , target_vars = None , thin_slice = True ) This file was automatically generated via lazydocs .","title":"greed.analyses.slicing"},{"location":"modules/greed.analyses.slicing/#module-greedanalysesslicing","text":"","title":"module greed.analyses.slicing"},{"location":"modules/greed.analyses.slicing/#function-inline_cfg","text":"inline_cfg ( p , cfg , max_rounds = 10 ) Inline max_depth levels of callprivates in the cfg, only when there is a single path in the callprivate","title":"function inline_cfg"},{"location":"modules/greed.analyses.slicing/#function-backward_slice","text":"backward_slice ( p , target_addr , target_vars = None , thin_slice = True )","title":"function backward_slice"},{"location":"modules/greed.analyses.slicing/#function-forward_slice","text":"forward_slice ( p , target_addr , target_vars = None , thin_slice = True )","title":"function forward_slice"},{"location":"modules/greed.analyses.slicing/#function-bidirectional_slice","text":"bidirectional_slice ( p , target_addr , target_vars = None , thin_slice = True ) This file was automatically generated via lazydocs .","title":"function bidirectional_slice"},{"location":"modules/greed.block/","text":"module greed.block class Block A TAC Basic Block. method __init__ __init__ ( statements : List [ TAC_Statement ], block_id : str ) Args: statements : List of TAC statements block_id : Block id property acyclic_subgraph Returns: Subgraph with this basic block as the root node (without cycles) property ancestors Returns: List of ancestors blocks property descendants Returns: List of descendants blocks property pred Returns: List of predecessors blocks property subgraph Returns: Subgraph with this basic block as the root node (with cycles) property succ Returns: List of successors blocks This file was automatically generated via lazydocs .","title":"greed.block"},{"location":"modules/greed.block/#module-greedblock","text":"","title":"module greed.block"},{"location":"modules/greed.block/#class-block","text":"A TAC Basic Block.","title":"class Block"},{"location":"modules/greed.block/#method-__init__","text":"__init__ ( statements : List [ TAC_Statement ], block_id : str ) Args: statements : List of TAC statements block_id : Block id","title":"method __init__"},{"location":"modules/greed.block/#property-acyclic_subgraph","text":"Returns: Subgraph with this basic block as the root node (without cycles)","title":"property acyclic_subgraph"},{"location":"modules/greed.block/#property-ancestors","text":"Returns: List of ancestors blocks","title":"property ancestors"},{"location":"modules/greed.block/#property-descendants","text":"Returns: List of descendants blocks","title":"property descendants"},{"location":"modules/greed.block/#property-pred","text":"Returns: List of predecessors blocks","title":"property pred"},{"location":"modules/greed.block/#property-subgraph","text":"Returns: Subgraph with this basic block as the root node (with cycles)","title":"property subgraph"},{"location":"modules/greed.block/#property-succ","text":"Returns: List of successors blocks This file was automatically generated via lazydocs .","title":"property succ"},{"location":"modules/greed.cfg/","text":"module greed.cfg class CFG This class represents a CFG of a function. method __init__ __init__ () property dominators Compute the dominators of the CFG. property stmt_cfg method dump dump ( filename ) Dump the CFG to a .dot file. Args: filename : The name of the output file. method filter_stmt filter_stmt ( names : List [ str ]) This file was automatically generated via lazydocs .","title":"greed.cfg"},{"location":"modules/greed.cfg/#module-greedcfg","text":"","title":"module greed.cfg"},{"location":"modules/greed.cfg/#class-cfg","text":"This class represents a CFG of a function.","title":"class CFG"},{"location":"modules/greed.cfg/#method-__init__","text":"__init__ ()","title":"method __init__"},{"location":"modules/greed.cfg/#property-dominators","text":"Compute the dominators of the CFG.","title":"property dominators"},{"location":"modules/greed.cfg/#property-stmt_cfg","text":"","title":"property stmt_cfg"},{"location":"modules/greed.cfg/#method-dump","text":"dump ( filename ) Dump the CFG to a .dot file. Args: filename : The name of the output file.","title":"method dump"},{"location":"modules/greed.cfg/#method-filter_stmt","text":"filter_stmt ( names : List [ str ]) This file was automatically generated via lazydocs .","title":"method filter_stmt"},{"location":"modules/greed.exploration_techniques.dfs/","text":"module greed.exploration_techniques.dfs class DFS This Exploration technique implements a Classic Depth-First Search exploration Args: deferred_stash : the name of the stash where deferred states are put method __init__ __init__ ( deferred_stash = 'deferred' ) method check_stashes check_stashes ( simgr , stashes , stash = 'active' ) If multiple states are in the active stash, move all but the oldest to the deferred stash. Args: simgr : the simulation manager stashes : the stashes stash : the name of the stash to check method is_complete is_complete ( simgr , stash = 'active' ) Check if the exploration is complete: there are no active states, and no deferred states. Args: simgr : the simulation manager stash : the name of the stash to check method setup setup ( simgr ) Setup the technique. Args: simgr : the simulation manager This file was automatically generated via lazydocs .","title":"greed.exploration_techniques.dfs"},{"location":"modules/greed.exploration_techniques.dfs/#module-greedexploration_techniquesdfs","text":"","title":"module greed.exploration_techniques.dfs"},{"location":"modules/greed.exploration_techniques.dfs/#class-dfs","text":"This Exploration technique implements a Classic Depth-First Search exploration Args: deferred_stash : the name of the stash where deferred states are put","title":"class DFS"},{"location":"modules/greed.exploration_techniques.dfs/#method-__init__","text":"__init__ ( deferred_stash = 'deferred' )","title":"method __init__"},{"location":"modules/greed.exploration_techniques.dfs/#method-check_stashes","text":"check_stashes ( simgr , stashes , stash = 'active' ) If multiple states are in the active stash, move all but the oldest to the deferred stash. Args: simgr : the simulation manager stashes : the stashes stash : the name of the stash to check","title":"method check_stashes"},{"location":"modules/greed.exploration_techniques.dfs/#method-is_complete","text":"is_complete ( simgr , stash = 'active' ) Check if the exploration is complete: there are no active states, and no deferred states. Args: simgr : the simulation manager stash : the name of the stash to check","title":"method is_complete"},{"location":"modules/greed.exploration_techniques.dfs/#method-setup","text":"setup ( simgr ) Setup the technique. Args: simgr : the simulation manager This file was automatically generated via lazydocs .","title":"method setup"},{"location":"modules/greed.exploration_techniques.directed_search/","text":"module greed.exploration_techniques.directed_search class DirectedSearch This technique prunes all states that cannot reach the block of a specified target statement. Possibly more effective when combined with DFS if only one path is needed: directed_search = DirectedSearch(target_stmt) simgr.use_technique(directed_search) dfs = DFS() simgr.use_technique(dfs) simgr.run(find=lambda s: s.curr_stmt.id == target_stmt_id) Args: target_stmt : the target Statement that we want to reach pruned_stash : the name of the stash where pruned states are put method __init__ __init__ ( target_stmt , pruned_stash = 'pruned' ) method check_successors check_successors ( simgr , successors ) Calculate the successors that can reach the target block, otherwise prune them. Args: simgr : the simulation manager successors : the successors to check method setup setup ( simgr ) Setup the technique. Args: simgr : the simulation manager This file was automatically generated via lazydocs .","title":"greed.exploration_techniques.directed_search"},{"location":"modules/greed.exploration_techniques.directed_search/#module-greedexploration_techniquesdirected_search","text":"","title":"module greed.exploration_techniques.directed_search"},{"location":"modules/greed.exploration_techniques.directed_search/#class-directedsearch","text":"This technique prunes all states that cannot reach the block of a specified target statement. Possibly more effective when combined with DFS if only one path is needed: directed_search = DirectedSearch(target_stmt) simgr.use_technique(directed_search) dfs = DFS() simgr.use_technique(dfs) simgr.run(find=lambda s: s.curr_stmt.id == target_stmt_id) Args: target_stmt : the target Statement that we want to reach pruned_stash : the name of the stash where pruned states are put","title":"class DirectedSearch"},{"location":"modules/greed.exploration_techniques.directed_search/#method-__init__","text":"__init__ ( target_stmt , pruned_stash = 'pruned' )","title":"method __init__"},{"location":"modules/greed.exploration_techniques.directed_search/#method-check_successors","text":"check_successors ( simgr , successors ) Calculate the successors that can reach the target block, otherwise prune them. Args: simgr : the simulation manager successors : the successors to check","title":"method check_successors"},{"location":"modules/greed.exploration_techniques.directed_search/#method-setup","text":"setup ( simgr ) Setup the technique. Args: simgr : the simulation manager This file was automatically generated via lazydocs .","title":"method setup"},{"location":"modules/greed.exploration_techniques.exploration_technique/","text":"module greed.exploration_techniques.exploration_technique class ExplorationTechnique Base Exploration Technique ALL THE STANDARD METHODS ARE NOT SUPPOSED TO BE CALLED MANUALLY method check_stashes check_stashes ( simgr , stashes ) This method receives the current active stashes that can be manipulated/re-ordered/etc... MUST return the stashes. Args: simgr : Simulation Manager stashes : All the active stashes Returns: MUST return the stashes. method check_state check_state ( simgr , state ) This method receives the state that we are going to generate the successors for. MUST return the state. Args: simgr : Simulation Manager state : State that we are going to generate the successors for Returns: MUST return the state. method check_successors check_successors ( simgr , successors ) This method receives all the successors generated from a step of a state. MUST return the successors. Args: simgr : Simulation Manager successors : All the successors generated from a step of a state Returns: MUST return the filtered successors method is_complete is_complete ( simgr ) This method indicate when the ET is done. If you just want to be done when there are no active states, just return True. Args: simgr : Simulation Manager Returns: Completion state method setup setup ( simgr ) Any operations that needs to be done on the simulation manager before starting the exploration with this technique. Args: simgr : Simulation Manager Returns: None This file was automatically generated via lazydocs .","title":"greed.exploration_techniques.exploration_technique"},{"location":"modules/greed.exploration_techniques.exploration_technique/#module-greedexploration_techniquesexploration_technique","text":"","title":"module greed.exploration_techniques.exploration_technique"},{"location":"modules/greed.exploration_techniques.exploration_technique/#class-explorationtechnique","text":"Base Exploration Technique ALL THE STANDARD METHODS ARE NOT SUPPOSED TO BE CALLED MANUALLY","title":"class ExplorationTechnique"},{"location":"modules/greed.exploration_techniques.exploration_technique/#method-check_stashes","text":"check_stashes ( simgr , stashes ) This method receives the current active stashes that can be manipulated/re-ordered/etc... MUST return the stashes. Args: simgr : Simulation Manager stashes : All the active stashes Returns: MUST return the stashes.","title":"method check_stashes"},{"location":"modules/greed.exploration_techniques.exploration_technique/#method-check_state","text":"check_state ( simgr , state ) This method receives the state that we are going to generate the successors for. MUST return the state. Args: simgr : Simulation Manager state : State that we are going to generate the successors for Returns: MUST return the state.","title":"method check_state"},{"location":"modules/greed.exploration_techniques.exploration_technique/#method-check_successors","text":"check_successors ( simgr , successors ) This method receives all the successors generated from a step of a state. MUST return the successors. Args: simgr : Simulation Manager successors : All the successors generated from a step of a state Returns: MUST return the filtered successors","title":"method check_successors"},{"location":"modules/greed.exploration_techniques.exploration_technique/#method-is_complete","text":"is_complete ( simgr ) This method indicate when the ET is done. If you just want to be done when there are no active states, just return True. Args: simgr : Simulation Manager Returns: Completion state","title":"method is_complete"},{"location":"modules/greed.exploration_techniques.exploration_technique/#method-setup","text":"setup ( simgr ) Any operations that needs to be done on the simulation manager before starting the exploration with this technique. Args: simgr : Simulation Manager Returns: None This file was automatically generated via lazydocs .","title":"method setup"},{"location":"modules/greed.exploration_techniques.heartbeat/","text":"module greed.exploration_techniques.heartbeat class HeartBeat This Exploration technique implements a Classic heartbeat. The heartbeat file will be logged during init . Delete such file to stop the heartbeat and get an ipdb shell. Args: beat_interval : the number of steps between heartbeats show_op : show the current operation during the heartbeat method __init__ __init__ ( beat_interval = 100 , show_op = False ) method change_beat change_beat ( new_beat_interval ) Change the beat interval. Args: new_beat_interval : the new beat interval. method check_successors check_successors ( simgr , successors ) Check if the heartbeat should be printed. Args: simgr : the simulation manager successors : the successors to check This file was automatically generated via lazydocs .","title":"greed.exploration_techniques.heartbeat"},{"location":"modules/greed.exploration_techniques.heartbeat/#module-greedexploration_techniquesheartbeat","text":"","title":"module greed.exploration_techniques.heartbeat"},{"location":"modules/greed.exploration_techniques.heartbeat/#class-heartbeat","text":"This Exploration technique implements a Classic heartbeat. The heartbeat file will be logged during init . Delete such file to stop the heartbeat and get an ipdb shell. Args: beat_interval : the number of steps between heartbeats show_op : show the current operation during the heartbeat","title":"class HeartBeat"},{"location":"modules/greed.exploration_techniques.heartbeat/#method-__init__","text":"__init__ ( beat_interval = 100 , show_op = False )","title":"method __init__"},{"location":"modules/greed.exploration_techniques.heartbeat/#method-change_beat","text":"change_beat ( new_beat_interval ) Change the beat interval. Args: new_beat_interval : the new beat interval.","title":"method change_beat"},{"location":"modules/greed.exploration_techniques.heartbeat/#method-check_successors","text":"check_successors ( simgr , successors ) Check if the heartbeat should be printed. Args: simgr : the simulation manager successors : the successors to check This file was automatically generated via lazydocs .","title":"method check_successors"},{"location":"modules/greed.exploration_techniques.other/","text":"module greed.exploration_techniques.other class Whitelist This technique skips all statements that are not in the whitelist until one of them is reached. The result variables of the skipped statements are set to a fresh symbolic variable. Args: whitelist : the list of statements' names in the whitelist (e.g., [\"MSTORE\", \"MLOAD\"]) method __init__ __init__ ( whitelist ) method check_state check_state ( simgr , state ) Check if the current statement is in the whitelist. If not, skip to the next statement. class LoopLimiter This technique limits the number of times a loop can be executed. When the limit is reached, the state is halted. Args: n : the maximum number of times a loop can be executed method __init__ __init__ ( n ) method check_state check_state ( simgr , state ) Check if the loop has been executed more than n times. If so, halt the state. Args: simgr : the simulation manager state : the state to check method setup setup ( simgr ) Setup the technique. Args: simgr : the simulation manager class MstoreConcretizer This technique concretizes the offset of MSTOREs. method __init__ __init__ () method check_state check_state ( simgr , state ) method setup setup ( simgr , _debug = False ) Setup the technique. Args: simgr : the simulation manager _debug : whether to print debug info This file was automatically generated via lazydocs .","title":"greed.exploration_techniques.other"},{"location":"modules/greed.exploration_techniques.other/#module-greedexploration_techniquesother","text":"","title":"module greed.exploration_techniques.other"},{"location":"modules/greed.exploration_techniques.other/#class-whitelist","text":"This technique skips all statements that are not in the whitelist until one of them is reached. The result variables of the skipped statements are set to a fresh symbolic variable. Args: whitelist : the list of statements' names in the whitelist (e.g., [\"MSTORE\", \"MLOAD\"])","title":"class Whitelist"},{"location":"modules/greed.exploration_techniques.other/#method-__init__","text":"__init__ ( whitelist )","title":"method __init__"},{"location":"modules/greed.exploration_techniques.other/#method-check_state","text":"check_state ( simgr , state ) Check if the current statement is in the whitelist. If not, skip to the next statement.","title":"method check_state"},{"location":"modules/greed.exploration_techniques.other/#class-looplimiter","text":"This technique limits the number of times a loop can be executed. When the limit is reached, the state is halted. Args: n : the maximum number of times a loop can be executed","title":"class LoopLimiter"},{"location":"modules/greed.exploration_techniques.other/#method-__init___1","text":"__init__ ( n )","title":"method __init__"},{"location":"modules/greed.exploration_techniques.other/#method-check_state_1","text":"check_state ( simgr , state ) Check if the loop has been executed more than n times. If so, halt the state. Args: simgr : the simulation manager state : the state to check","title":"method check_state"},{"location":"modules/greed.exploration_techniques.other/#method-setup","text":"setup ( simgr ) Setup the technique. Args: simgr : the simulation manager","title":"method setup"},{"location":"modules/greed.exploration_techniques.other/#class-mstoreconcretizer","text":"This technique concretizes the offset of MSTOREs.","title":"class MstoreConcretizer"},{"location":"modules/greed.exploration_techniques.other/#method-__init___2","text":"__init__ ()","title":"method __init__"},{"location":"modules/greed.exploration_techniques.other/#method-check_state_2","text":"check_state ( simgr , state )","title":"method check_state"},{"location":"modules/greed.exploration_techniques.other/#method-setup_1","text":"setup ( simgr , _debug = False ) Setup the technique. Args: simgr : the simulation manager _debug : whether to print debug info This file was automatically generated via lazydocs .","title":"method setup"},{"location":"modules/greed.exploration_techniques.prioritizer/","text":"module greed.exploration_techniques.prioritizer class Prioritizer This Exploration technique implements a DFS with prioritization of states. The prioritization is done by a scoring function that is applied to each state. For instance, the scoring function can be the distance (in basic blocks) from a target statement. Args: scoring_function : the scoring function deferred_stash : the name of the stash where deferred states are put method __init__ __init__ ( scoring_function , deferred_stash = 'deferred' ) method check_stashes check_stashes ( simgr , stashes , stash = 'active' ) method is_complete is_complete ( simgr , stash = 'active' ) method setup setup ( simgr ) This file was automatically generated via lazydocs .","title":"greed.exploration_techniques.prioritizer"},{"location":"modules/greed.exploration_techniques.prioritizer/#module-greedexploration_techniquesprioritizer","text":"","title":"module greed.exploration_techniques.prioritizer"},{"location":"modules/greed.exploration_techniques.prioritizer/#class-prioritizer","text":"This Exploration technique implements a DFS with prioritization of states. The prioritization is done by a scoring function that is applied to each state. For instance, the scoring function can be the distance (in basic blocks) from a target statement. Args: scoring_function : the scoring function deferred_stash : the name of the stash where deferred states are put","title":"class Prioritizer"},{"location":"modules/greed.exploration_techniques.prioritizer/#method-__init__","text":"__init__ ( scoring_function , deferred_stash = 'deferred' )","title":"method __init__"},{"location":"modules/greed.exploration_techniques.prioritizer/#method-check_stashes","text":"check_stashes ( simgr , stashes , stash = 'active' )","title":"method check_stashes"},{"location":"modules/greed.exploration_techniques.prioritizer/#method-is_complete","text":"is_complete ( simgr , stash = 'active' )","title":"method is_complete"},{"location":"modules/greed.exploration_techniques.prioritizer/#method-setup","text":"setup ( simgr ) This file was automatically generated via lazydocs .","title":"method setup"},{"location":"modules/greed.exploration_techniques.simgrviz/","text":"module greed.exploration_techniques.simgrviz class SimgrViz This Exploration technique implements visualizes and dumps the simulation manager progress. The .dot output file will be logged during _dump_graph. method __init__ __init__ () method check_stashes check_stashes ( simgr , stashes ) method check_state check_state ( simgr , state ) method check_successors check_successors ( simgr , successors ) method setup setup ( simgr ) This file was automatically generated via lazydocs .","title":"greed.exploration_techniques.simgrviz"},{"location":"modules/greed.exploration_techniques.simgrviz/#module-greedexploration_techniquessimgrviz","text":"","title":"module greed.exploration_techniques.simgrviz"},{"location":"modules/greed.exploration_techniques.simgrviz/#class-simgrviz","text":"This Exploration technique implements visualizes and dumps the simulation manager progress. The .dot output file will be logged during _dump_graph.","title":"class SimgrViz"},{"location":"modules/greed.exploration_techniques.simgrviz/#method-__init__","text":"__init__ ()","title":"method __init__"},{"location":"modules/greed.exploration_techniques.simgrviz/#method-check_stashes","text":"check_stashes ( simgr , stashes )","title":"method check_stashes"},{"location":"modules/greed.exploration_techniques.simgrviz/#method-check_state","text":"check_state ( simgr , state )","title":"method check_state"},{"location":"modules/greed.exploration_techniques.simgrviz/#method-check_successors","text":"check_successors ( simgr , successors )","title":"method check_successors"},{"location":"modules/greed.exploration_techniques.simgrviz/#method-setup","text":"setup ( simgr ) This file was automatically generated via lazydocs .","title":"method setup"},{"location":"modules/greed.factory/","text":"module greed.factory class Factory This class is used as a constructor of different objects: - SimulationManager - SimState - Block - TAC_Statement - TAC_Function method __init__ __init__ ( project : 'Project' ) method block block ( block_id : str ) \u2192 Block method entry_state entry_state ( xid : str , init_ctx : dict = None , options : dict = None , max_calldatasize : int = None , partial_concrete_storage : bool = False ) \u2192 SymbolicEVMState method function function ( function_id : str ) \u2192 TAC_Function method simgr simgr ( entry_state : SymbolicEVMState ) \u2192 SimulationManager method statement statement ( stmt_id : str ) \u2192 TAC_Statement This file was automatically generated via lazydocs .","title":"greed.factory"},{"location":"modules/greed.factory/#module-greedfactory","text":"","title":"module greed.factory"},{"location":"modules/greed.factory/#class-factory","text":"This class is used as a constructor of different objects: - SimulationManager - SimState - Block - TAC_Statement - TAC_Function","title":"class Factory"},{"location":"modules/greed.factory/#method-__init__","text":"__init__ ( project : 'Project' )","title":"method __init__"},{"location":"modules/greed.factory/#method-block","text":"block ( block_id : str ) \u2192 Block","title":"method block"},{"location":"modules/greed.factory/#method-entry_state","text":"entry_state ( xid : str , init_ctx : dict = None , options : dict = None , max_calldatasize : int = None , partial_concrete_storage : bool = False ) \u2192 SymbolicEVMState","title":"method entry_state"},{"location":"modules/greed.factory/#method-function","text":"function ( function_id : str ) \u2192 TAC_Function","title":"method function"},{"location":"modules/greed.factory/#method-simgr","text":"simgr ( entry_state : SymbolicEVMState ) \u2192 SimulationManager","title":"method simgr"},{"location":"modules/greed.factory/#method-statement","text":"statement ( stmt_id : str ) \u2192 TAC_Statement This file was automatically generated via lazydocs .","title":"method statement"},{"location":"modules/greed.function/","text":"module greed.function class TAC_Function This class represents a TAC function. method __init__ __init__ ( id : str , signature : str , name : str , public : bool , blocks : List [ Block ], arguments : List [ str ] ) Args: id : The id of the function signature : The signature of the function name : The name of the function public : Whether the function is public or not blocks : The list of blocks that compose the function arguments : The list of arguments of the function method build_cfg build_cfg ( factory : Factory , tac_block_succ : Mapping [ str , List [ str ]]) Building the intra-functional CFG of a target function. Args: factory : The factory object tac_block_succ : The mapping between block ids and their successors method build_use_def_graph build_use_def_graph () Building the use-def graph of a target function. method dump_use_def_graph dump_use_def_graph ( filename ) Dump the use-def graph to a .dot file. Args: filename : The name of the output file. This file was automatically generated via lazydocs .","title":"greed.function"},{"location":"modules/greed.function/#module-greedfunction","text":"","title":"module greed.function"},{"location":"modules/greed.function/#class-tac_function","text":"This class represents a TAC function.","title":"class TAC_Function"},{"location":"modules/greed.function/#method-__init__","text":"__init__ ( id : str , signature : str , name : str , public : bool , blocks : List [ Block ], arguments : List [ str ] ) Args: id : The id of the function signature : The signature of the function name : The name of the function public : Whether the function is public or not blocks : The list of blocks that compose the function arguments : The list of arguments of the function","title":"method __init__"},{"location":"modules/greed.function/#method-build_cfg","text":"build_cfg ( factory : Factory , tac_block_succ : Mapping [ str , List [ str ]]) Building the intra-functional CFG of a target function. Args: factory : The factory object tac_block_succ : The mapping between block ids and their successors","title":"method build_cfg"},{"location":"modules/greed.function/#method-build_use_def_graph","text":"build_use_def_graph () Building the use-def graph of a target function.","title":"method build_use_def_graph"},{"location":"modules/greed.function/#method-dump_use_def_graph","text":"dump_use_def_graph ( filename ) Dump the use-def graph to a .dot file. Args: filename : The name of the output file. This file was automatically generated via lazydocs .","title":"method dump_use_def_graph"},{"location":"modules/greed.memory.lambda_constraint/","text":"module greed.memory.lambda_constraint class LambdaConstraint Base class for uninstantiated constraints (see the LambdaMemory class) Extending the Theory of Arrays: memset, memcpy, and Beyond (https://llbmc.org/files/papers/VSTTE13.pdf) see 5.3 \"Instantiating Quantifiers\" method __init__ __init__ ( array = None , new_array = None , parent = None ) method copy copy ( new_state ) method instantiate instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index Returns: All instantiated constraints (recursively from the LambdaConstraint hierarchy) class LambdaMemsetConstraint Uninstantiated memset constraint method __init__ __init__ ( array , start , value , size , new_array , parent ) Args: array : the SMT array on which the memset is applied start : the start index value : the value to write size : how many bytes to write new_array : the new array (after the memset) parent : the parent LambdaConstraint method copy copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state method instantiate instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index class LambdaMemsetInfiniteConstraint Uninstantiated memset infinite constraint method __init__ __init__ ( array , start , value , new_array , parent ) Args: array : the SMT array on which the memset is applied start : the start index value : the value to write new_array : the new array (after the memset) parent : the parent LambdaConstraint method copy copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state method instantiate instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index class LambdaMemcopyConstraint Uninstantiated memcopy constraint method __init__ __init__ ( array , start , source , source_start , size , new_array , parent ) Args: array : the SMT array src start : the start index source : the source array source_start : the start index of the source array size : how many bytes to write new_array : the SMT array target of the memcopy parent : the parent LambdaConstraint method copy copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state method instantiate instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index class LambdaMemcopyInfiniteConstraint Uninstantiated memcopy infinite constraint method __init__ __init__ ( array , start , source , source_start , new_array , parent ) Args: array : the SMT array src start : the start index source : the source array source_start : the start index of the source array new_array : the SMT array target of the memcopy parent : the parent LambdaConstraint method copy copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state method instantiate instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index This file was automatically generated via lazydocs .","title":"greed.memory.lambda_constraint"},{"location":"modules/greed.memory.lambda_constraint/#module-greedmemorylambda_constraint","text":"","title":"module greed.memory.lambda_constraint"},{"location":"modules/greed.memory.lambda_constraint/#class-lambdaconstraint","text":"Base class for uninstantiated constraints (see the LambdaMemory class) Extending the Theory of Arrays: memset, memcpy, and Beyond (https://llbmc.org/files/papers/VSTTE13.pdf) see 5.3 \"Instantiating Quantifiers\"","title":"class LambdaConstraint"},{"location":"modules/greed.memory.lambda_constraint/#method-__init__","text":"__init__ ( array = None , new_array = None , parent = None )","title":"method __init__"},{"location":"modules/greed.memory.lambda_constraint/#method-copy","text":"copy ( new_state )","title":"method copy"},{"location":"modules/greed.memory.lambda_constraint/#method-instantiate","text":"instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index Returns: All instantiated constraints (recursively from the LambdaConstraint hierarchy)","title":"method instantiate"},{"location":"modules/greed.memory.lambda_constraint/#class-lambdamemsetconstraint","text":"Uninstantiated memset constraint","title":"class LambdaMemsetConstraint"},{"location":"modules/greed.memory.lambda_constraint/#method-__init___1","text":"__init__ ( array , start , value , size , new_array , parent ) Args: array : the SMT array on which the memset is applied start : the start index value : the value to write size : how many bytes to write new_array : the new array (after the memset) parent : the parent LambdaConstraint","title":"method __init__"},{"location":"modules/greed.memory.lambda_constraint/#method-copy_1","text":"copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state","title":"method copy"},{"location":"modules/greed.memory.lambda_constraint/#method-instantiate_1","text":"instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index","title":"method instantiate"},{"location":"modules/greed.memory.lambda_constraint/#class-lambdamemsetinfiniteconstraint","text":"Uninstantiated memset infinite constraint","title":"class LambdaMemsetInfiniteConstraint"},{"location":"modules/greed.memory.lambda_constraint/#method-__init___2","text":"__init__ ( array , start , value , new_array , parent ) Args: array : the SMT array on which the memset is applied start : the start index value : the value to write new_array : the new array (after the memset) parent : the parent LambdaConstraint","title":"method __init__"},{"location":"modules/greed.memory.lambda_constraint/#method-copy_2","text":"copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state","title":"method copy"},{"location":"modules/greed.memory.lambda_constraint/#method-instantiate_2","text":"instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index","title":"method instantiate"},{"location":"modules/greed.memory.lambda_constraint/#class-lambdamemcopyconstraint","text":"Uninstantiated memcopy constraint","title":"class LambdaMemcopyConstraint"},{"location":"modules/greed.memory.lambda_constraint/#method-__init___3","text":"__init__ ( array , start , source , source_start , size , new_array , parent ) Args: array : the SMT array src start : the start index source : the source array source_start : the start index of the source array size : how many bytes to write new_array : the SMT array target of the memcopy parent : the parent LambdaConstraint","title":"method __init__"},{"location":"modules/greed.memory.lambda_constraint/#method-copy_3","text":"copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state","title":"method copy"},{"location":"modules/greed.memory.lambda_constraint/#method-instantiate_3","text":"instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index","title":"method instantiate"},{"location":"modules/greed.memory.lambda_constraint/#class-lambdamemcopyinfiniteconstraint","text":"Uninstantiated memcopy infinite constraint","title":"class LambdaMemcopyInfiniteConstraint"},{"location":"modules/greed.memory.lambda_constraint/#method-__init___4","text":"__init__ ( array , start , source , source_start , new_array , parent ) Args: array : the SMT array src start : the start index source : the source array source_start : the start index of the source array new_array : the SMT array target of the memcopy parent : the parent LambdaConstraint","title":"method __init__"},{"location":"modules/greed.memory.lambda_constraint/#method-copy_4","text":"copy ( new_state ) Copy the constraint (on state copy) Args: new_state : the new state","title":"method copy"},{"location":"modules/greed.memory.lambda_constraint/#method-instantiate_4","text":"instantiate ( index ) Instantiate the constraint (on read) Args: index : The read index This file was automatically generated via lazydocs .","title":"method instantiate"},{"location":"modules/greed.memory.lambda_memory/","text":"module greed.memory.lambda_memory class LambdaMemory Implementation of an instantiation-based lambda memory Extending the Theory of Arrays: memset, memcpy, and Beyond (https://llbmc.org/files/papers/VSTTE13.pdf) see 5.3 \"Instantiating Quantifiers\" This is a memory implementation with memset/memsetinfinite/memcpy/memcpyinfinite primitives To provide such primitives, we generate constraints such as \"for all indices in the copied range, read from the source array, else read from the old array\" To make such constraints compatible with a Quantifier-Free logic, we use an instantiation-based approach, with layers of \"uninstantiated constraints\". The constraints are then instantiated ON READ (i.e., after reading index 42: \"if 42 is in the copied range, read from the source array, else read from the old array\"). Two successive copies can overlap with each other (RANGES CAN BE SYMBOLIC), which is why the layered architecture -and possibly useless constraints- are needed. Example: memcopy(start1, end1, source1, memory1) # uninstantiated constraints: \"for all indices i in (start1, end1), memory2[i] == source1[i], else memory2[i] == memory1[i]\" # instantiated constraints: memcopy(start2, end2, source2, memory2) # uninstantiated constraints: \"for all indices i in (start1, end1), memory2[i] == source1[i], else memory2[i] == memory1[i]\" \"for all indices i in (start2, end2), memory3[i] == source2[i], else memory3[i] == memory2[i]\" # instantiated constraints: read(42) --> return memory3[42] # uninstantiated constraints: \"for all indices i in (start1, end1), memory2[i] == source1[i], else memory2[i] == memory1[i]\" \"for all indices i in (start2, end2), memory3[i] == source2[i], else memory3[i] == memory2[i]\" # instantiated constraints: \"if 42 in (start1, end1), memory2[42] == source1[42], else memory2[42] == memory1[42]\" \"if 42 in (start2, end2), memory3[42] == source2[42], else memory3[42] == memory2[42]\" method __init__ __init__ ( tag = None , value_sort = None , default = None , state = None , partial_init = False ) Initialize the LambdaMemory. Args: tag : the tag of the memory, this is a unique identifier. value_sort : the sort type of the values in the memory (e.g., BVSort(8)) default : the default value of the memory when no writes have been performed state : the SimState to which this memory belongs partial_init : if True, do not initialize the memory property constraints Get the constraints of the memory. Returns: the constraints property layer_level How many layers of lambda constraints are there? Returns: the number of layers method add_constraint add_constraint ( formula ) Add a constraint to the memory. Args: formula : the constraint to add method add_constraints add_constraints ( formulas ) Add constraints to the memory. Args: formulas : the constraints to add method copy copy ( new_state ) Perform a deep copy of the memory. Args: new_state : the state to which the new memory belongs Returns: A deep copy of the LambdaMemory method memcopy memcopy ( start , source , source_start , size ) Perform a memcopy operation Args: start : the start index source : the source memory source_start : the start index of the source memory size : the number of bytes to copy Raises: AssertionError : if the source memory is different from the current memory method memcopyinfinite memcopyinfinite ( start , source , source_start ) Perform a memcopyinfinite operation Args: start : the start index source : the source memory source_start : the start index of the source memory Raises: AssertionError : if the source memory is different from the current memory method memset memset ( start , value , size ) Perform a memset operation Args: start : the start index value : the value to write size : the number of bytes to write method memsetinfinite memsetinfinite ( start , value ) Perform a memsetinfinite operation Args: start : the start index value : the value to write method readn readn ( index , n ) Read n bytes from the memory at a specific index. Args: index : the index to read from n : the number of bytes to read Returns: a BV_Concat formula representing the read Raises: AssertionError : if the length is symbolic AssertionError : if the length is 0 This file was automatically generated via lazydocs .","title":"greed.memory.lambda_memory"},{"location":"modules/greed.memory.lambda_memory/#module-greedmemorylambda_memory","text":"","title":"module greed.memory.lambda_memory"},{"location":"modules/greed.memory.lambda_memory/#class-lambdamemory","text":"Implementation of an instantiation-based lambda memory Extending the Theory of Arrays: memset, memcpy, and Beyond (https://llbmc.org/files/papers/VSTTE13.pdf) see 5.3 \"Instantiating Quantifiers\" This is a memory implementation with memset/memsetinfinite/memcpy/memcpyinfinite primitives To provide such primitives, we generate constraints such as \"for all indices in the copied range, read from the source array, else read from the old array\" To make such constraints compatible with a Quantifier-Free logic, we use an instantiation-based approach, with layers of \"uninstantiated constraints\". The constraints are then instantiated ON READ (i.e., after reading index 42: \"if 42 is in the copied range, read from the source array, else read from the old array\"). Two successive copies can overlap with each other (RANGES CAN BE SYMBOLIC), which is why the layered architecture -and possibly useless constraints- are needed. Example: memcopy(start1, end1, source1, memory1) # uninstantiated constraints: \"for all indices i in (start1, end1), memory2[i] == source1[i], else memory2[i] == memory1[i]\" # instantiated constraints: memcopy(start2, end2, source2, memory2) # uninstantiated constraints: \"for all indices i in (start1, end1), memory2[i] == source1[i], else memory2[i] == memory1[i]\" \"for all indices i in (start2, end2), memory3[i] == source2[i], else memory3[i] == memory2[i]\" # instantiated constraints: read(42) --> return memory3[42] # uninstantiated constraints: \"for all indices i in (start1, end1), memory2[i] == source1[i], else memory2[i] == memory1[i]\" \"for all indices i in (start2, end2), memory3[i] == source2[i], else memory3[i] == memory2[i]\" # instantiated constraints: \"if 42 in (start1, end1), memory2[42] == source1[42], else memory2[42] == memory1[42]\" \"if 42 in (start2, end2), memory3[42] == source2[42], else memory3[42] == memory2[42]\"","title":"class LambdaMemory"},{"location":"modules/greed.memory.lambda_memory/#method-__init__","text":"__init__ ( tag = None , value_sort = None , default = None , state = None , partial_init = False ) Initialize the LambdaMemory. Args: tag : the tag of the memory, this is a unique identifier. value_sort : the sort type of the values in the memory (e.g., BVSort(8)) default : the default value of the memory when no writes have been performed state : the SimState to which this memory belongs partial_init : if True, do not initialize the memory","title":"method __init__"},{"location":"modules/greed.memory.lambda_memory/#property-constraints","text":"Get the constraints of the memory. Returns: the constraints","title":"property constraints"},{"location":"modules/greed.memory.lambda_memory/#property-layer_level","text":"How many layers of lambda constraints are there? Returns: the number of layers","title":"property layer_level"},{"location":"modules/greed.memory.lambda_memory/#method-add_constraint","text":"add_constraint ( formula ) Add a constraint to the memory. Args: formula : the constraint to add","title":"method add_constraint"},{"location":"modules/greed.memory.lambda_memory/#method-add_constraints","text":"add_constraints ( formulas ) Add constraints to the memory. Args: formulas : the constraints to add","title":"method add_constraints"},{"location":"modules/greed.memory.lambda_memory/#method-copy","text":"copy ( new_state ) Perform a deep copy of the memory. Args: new_state : the state to which the new memory belongs Returns: A deep copy of the LambdaMemory","title":"method copy"},{"location":"modules/greed.memory.lambda_memory/#method-memcopy","text":"memcopy ( start , source , source_start , size ) Perform a memcopy operation Args: start : the start index source : the source memory source_start : the start index of the source memory size : the number of bytes to copy Raises: AssertionError : if the source memory is different from the current memory","title":"method memcopy"},{"location":"modules/greed.memory.lambda_memory/#method-memcopyinfinite","text":"memcopyinfinite ( start , source , source_start ) Perform a memcopyinfinite operation Args: start : the start index source : the source memory source_start : the start index of the source memory Raises: AssertionError : if the source memory is different from the current memory","title":"method memcopyinfinite"},{"location":"modules/greed.memory.lambda_memory/#method-memset","text":"memset ( start , value , size ) Perform a memset operation Args: start : the start index value : the value to write size : the number of bytes to write","title":"method memset"},{"location":"modules/greed.memory.lambda_memory/#method-memsetinfinite","text":"memsetinfinite ( start , value ) Perform a memsetinfinite operation Args: start : the start index value : the value to write","title":"method memsetinfinite"},{"location":"modules/greed.memory.lambda_memory/#method-readn","text":"readn ( index , n ) Read n bytes from the memory at a specific index. Args: index : the index to read from n : the number of bytes to read Returns: a BV_Concat formula representing the read Raises: AssertionError : if the length is symbolic AssertionError : if the length is 0 This file was automatically generated via lazydocs .","title":"method readn"},{"location":"modules/greed.memory.partial_concrete_storage/","text":"module greed.memory.partial_concrete_storage class PartialConcreteStorage This class represents a partial concrete storage. When using the partial concrete storage, reads from the contract storage (SLOADs) are initialized with the concrete value on-chain (at the given block number). To use this, we need a web3 connection to the blockchain, the address of the contract and the block number. method __init__ __init__ ( tag = None , value_sort = None , state = None , partial_init = False ) Initialize the partial concrete storage. Args: tag : The unique identifier of the storage value_sort : The sort of the values stored in the storage state : The SimState associated with this storage partial_init : If true, the storage is partially initialized (used for copy) Raises: GreedException : If the partial concrete storage is not initialized with the contract address and block number AssertionError : If the partial concrete storage is not initialized with the tag and value sort AssertionError : If w3 is not connected property constraints property layer_level method add_constraint add_constraint ( formula ) Add a constraint to the storage. Args: formula : The constraint to add method add_constraints add_constraints ( formulas ) Add a list of constraints to the storage. Args: formulas : The list of constraints to add method copy copy ( new_state ) Copy the partial concrete storage. Args: new_state : The new SimState associated with the new storage This file was automatically generated via lazydocs .","title":"greed.memory.partial_concrete_storage"},{"location":"modules/greed.memory.partial_concrete_storage/#module-greedmemorypartial_concrete_storage","text":"","title":"module greed.memory.partial_concrete_storage"},{"location":"modules/greed.memory.partial_concrete_storage/#class-partialconcretestorage","text":"This class represents a partial concrete storage. When using the partial concrete storage, reads from the contract storage (SLOADs) are initialized with the concrete value on-chain (at the given block number). To use this, we need a web3 connection to the blockchain, the address of the contract and the block number.","title":"class PartialConcreteStorage"},{"location":"modules/greed.memory.partial_concrete_storage/#method-__init__","text":"__init__ ( tag = None , value_sort = None , state = None , partial_init = False ) Initialize the partial concrete storage. Args: tag : The unique identifier of the storage value_sort : The sort of the values stored in the storage state : The SimState associated with this storage partial_init : If true, the storage is partially initialized (used for copy) Raises: GreedException : If the partial concrete storage is not initialized with the contract address and block number AssertionError : If the partial concrete storage is not initialized with the tag and value sort AssertionError : If w3 is not connected","title":"method __init__"},{"location":"modules/greed.memory.partial_concrete_storage/#property-constraints","text":"","title":"property constraints"},{"location":"modules/greed.memory.partial_concrete_storage/#property-layer_level","text":"","title":"property layer_level"},{"location":"modules/greed.memory.partial_concrete_storage/#method-add_constraint","text":"add_constraint ( formula ) Add a constraint to the storage. Args: formula : The constraint to add","title":"method add_constraint"},{"location":"modules/greed.memory.partial_concrete_storage/#method-add_constraints","text":"add_constraints ( formulas ) Add a list of constraints to the storage. Args: formulas : The list of constraints to add","title":"method add_constraints"},{"location":"modules/greed.memory.partial_concrete_storage/#method-copy","text":"copy ( new_state ) Copy the partial concrete storage. Args: new_state : The new SimState associated with the new storage This file was automatically generated via lazydocs .","title":"method copy"},{"location":"modules/greed.options/","text":"module greed.options Global Variables WEB3_PROVIDER LAZY_SOLVES GREEDY_SHA MIN_SHA_DISTANCE SIMGRVIZ STATE_INSPECT MAX_CALLDATA_SIZE MATH_CONCRETIZE_SYMBOLIC_EXP_EXP MATH_CONCRETIZE_SYMBOLIC_EXP_BASE MATH_MULTIPLY_EXP_THRESHOLD OPTIMISTIC_CALL_RESULTS DEFAULT_EXTCODESIZE DEFAULT_CREATE_RESULT_ADDRESS DEFAULT_CREATE2_RESULT_ADDRESS STATE_STOP_AT_ADDCONSTRAINT MAX_SHA_SIZE SOLVER_YICES2 SOLVER SOLVER_TIMEOUT This file was automatically generated via lazydocs .","title":"greed.options"},{"location":"modules/greed.options/#module-greedoptions","text":"","title":"module greed.options"},{"location":"modules/greed.options/#global-variables","text":"WEB3_PROVIDER LAZY_SOLVES GREEDY_SHA MIN_SHA_DISTANCE SIMGRVIZ STATE_INSPECT MAX_CALLDATA_SIZE MATH_CONCRETIZE_SYMBOLIC_EXP_EXP MATH_CONCRETIZE_SYMBOLIC_EXP_BASE MATH_MULTIPLY_EXP_THRESHOLD OPTIMISTIC_CALL_RESULTS DEFAULT_EXTCODESIZE DEFAULT_CREATE_RESULT_ADDRESS DEFAULT_CREATE2_RESULT_ADDRESS STATE_STOP_AT_ADDCONSTRAINT MAX_SHA_SIZE SOLVER_YICES2 SOLVER SOLVER_TIMEOUT This file was automatically generated via lazydocs .","title":"Global Variables"},{"location":"modules/greed.project/","text":"module greed.project class Project This is the main class for creating a greed Project! method __init__ __init__ ( target_dir : str ) Args: target_dir : The directory containing the contract.hex file and all the GigaHorse output files. method dump_callgraph dump_callgraph ( filename ) Dump the callgraph in a dot file. Args: filename : The name of the file where to dump the callgraph. This file was automatically generated via lazydocs .","title":"greed.project"},{"location":"modules/greed.project/#module-greedproject","text":"","title":"module greed.project"},{"location":"modules/greed.project/#class-project","text":"This is the main class for creating a greed Project!","title":"class Project"},{"location":"modules/greed.project/#method-__init__","text":"__init__ ( target_dir : str ) Args: target_dir : The directory containing the contract.hex file and all the GigaHorse output files.","title":"method __init__"},{"location":"modules/greed.project/#method-dump_callgraph","text":"dump_callgraph ( filename ) Dump the callgraph in a dot file. Args: filename : The name of the file where to dump the callgraph. This file was automatically generated via lazydocs .","title":"method dump_callgraph"},{"location":"modules/greed.sha3/","text":"module greed.sha3 class Sha3 This class represents the memory used as a input buffer for the SHA3 operation. (SHA3 needs to be of type LambdaMemory to allow the (bounded) comparison between two SHA(s) (see ca. line 50)) method __init__ __init__ ( state = None , memory = None , start = None , size = None , partial_init = False ) Args: state : The SimState that triggers the SHA3 operation memory : The memory associated to the SimState start : The start of the input buffer for the SHA3 operation size : The size of the input buffer for the SHA3 operation partial_init : Whether to partially initialize the object or not property constraints Get the constraints of the memory. Returns: the constraints property layer_level How many layers of lambda constraints are there? Returns: the number of layers method copy copy ( new_state ) Deep copy of the object. Args: new_state : The new state method instantiate_ackermann_constraints instantiate_ackermann_constraints ( other ) This method instantiates the Ackermann constraints between the two SHA(s). Args: other : The other SHA3 object This file was automatically generated via lazydocs .","title":"greed.sha3"},{"location":"modules/greed.sha3/#module-greedsha3","text":"","title":"module greed.sha3"},{"location":"modules/greed.sha3/#class-sha3","text":"This class represents the memory used as a input buffer for the SHA3 operation. (SHA3 needs to be of type LambdaMemory to allow the (bounded) comparison between two SHA(s) (see ca. line 50))","title":"class Sha3"},{"location":"modules/greed.sha3/#method-__init__","text":"__init__ ( state = None , memory = None , start = None , size = None , partial_init = False ) Args: state : The SimState that triggers the SHA3 operation memory : The memory associated to the SimState start : The start of the input buffer for the SHA3 operation size : The size of the input buffer for the SHA3 operation partial_init : Whether to partially initialize the object or not","title":"method __init__"},{"location":"modules/greed.sha3/#property-constraints","text":"Get the constraints of the memory. Returns: the constraints","title":"property constraints"},{"location":"modules/greed.sha3/#property-layer_level","text":"How many layers of lambda constraints are there? Returns: the number of layers","title":"property layer_level"},{"location":"modules/greed.sha3/#method-copy","text":"copy ( new_state ) Deep copy of the object. Args: new_state : The new state","title":"method copy"},{"location":"modules/greed.sha3/#method-instantiate_ackermann_constraints","text":"instantiate_ackermann_constraints ( other ) This method instantiates the Ackermann constraints between the two SHA(s). Args: other : The other SHA3 object This file was automatically generated via lazydocs .","title":"method instantiate_ackermann_constraints"},{"location":"modules/greed.sim_manager/","text":"module greed.sim_manager Global Variables TYPE_CHECKING class SimulationManager This class is the main class for running the symbolic execution. The simulation manager is responsible for keeping track of the states, and for moving them between the different stashes according to the employed exploration techniques. method __init__ __init__ ( entry_state : SymbolicEVMState , project ) Args: entry_state : The entry state of the simulation manager project : The greed project property active Returns: All the active states property deadended Returns: All the deadended states (halted states) property found Returns: All the found states (states that met the find condition) property one_active Returns: First element of the active stash, or None if the stash is empty property one_deadended Returns: First element of the deadended stash, or None if the stash is empty property one_found Returns: First element of the found stash, or None if the stash is empty property states Returns: All the states in the simulation manager method findall findall ( find : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6980 > , prune : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6a20 > ) Run the simulation manager, until the find condition of all the ET is met. Args: find : Function that will be called after each step. The matching states will be moved to the found stash prune : Function that will be called after each step. The matching states will be moved to the pruned stash Yield: The found states Raises: Exception : If something goes wrong while stepping the simulation manager method move move ( from_stash : str , to_stash : str , filter_func : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d63e0 > ) Move all the states that meet the filter_func condition from from_stash to to_stash Args: from_stash : Source stash to_stash : Destination Stash filter_func : A function that discriminates what states should be moved method run run ( find : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d67a0 > , prune : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6840 > , find_all = False ) Run the simulation manager, until the find condition is met. The analysis will stop when there are no more active states, some states met the find condition (these will be moved to the found stash), or the exploration techniques are done. If no ET are plugged, the default searching strategy is BFS. When techniques are plugged, their methods are executed following the same order they were plugged. e.g., assuming we have T1 and T2. T1(check_stashes) -> T2(check_stashes) -> T1(check_state) -> T2(check_state) -> T1(check_successors) -> T2(check_successors) Args: find : Function that will be called after each step. The matching states will be moved to the found stash prune : Function that will be called after each step. The matching states will be moved to the pruned stash find_all : If True, the analysis will continue until all the ET meet the find condition Raises: Exception : If something goes wrong while stepping the simulation manager method set_error set_error ( s : str ) Set an error to the simulation manager method single_step_state single_step_state ( state : SymbolicEVMState ) \u2192 List [ SymbolicEVMState ] Step a single state (calculate its successors) Args: state : The state to step Returns: The successors of the state Raises: Exception : If something goes wrong while generating the successors method step step ( find : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6520 > , prune : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d65c0 > ) Step the simulation manager, i.e., step all the active states. Args: find : A function that discriminates what states should be moved to the found stash prune : A function that discriminates what states should be moved to the pruned stash method use_technique use_technique ( technique : 'ExplorationTechnique' ) Install an exploration technique in the simulation manager. This file was automatically generated via lazydocs .","title":"greed.sim_manager"},{"location":"modules/greed.sim_manager/#module-greedsim_manager","text":"","title":"module greed.sim_manager"},{"location":"modules/greed.sim_manager/#global-variables","text":"TYPE_CHECKING","title":"Global Variables"},{"location":"modules/greed.sim_manager/#class-simulationmanager","text":"This class is the main class for running the symbolic execution. The simulation manager is responsible for keeping track of the states, and for moving them between the different stashes according to the employed exploration techniques.","title":"class SimulationManager"},{"location":"modules/greed.sim_manager/#method-__init__","text":"__init__ ( entry_state : SymbolicEVMState , project ) Args: entry_state : The entry state of the simulation manager project : The greed project","title":"method __init__"},{"location":"modules/greed.sim_manager/#property-active","text":"Returns: All the active states","title":"property active"},{"location":"modules/greed.sim_manager/#property-deadended","text":"Returns: All the deadended states (halted states)","title":"property deadended"},{"location":"modules/greed.sim_manager/#property-found","text":"Returns: All the found states (states that met the find condition)","title":"property found"},{"location":"modules/greed.sim_manager/#property-one_active","text":"Returns: First element of the active stash, or None if the stash is empty","title":"property one_active"},{"location":"modules/greed.sim_manager/#property-one_deadended","text":"Returns: First element of the deadended stash, or None if the stash is empty","title":"property one_deadended"},{"location":"modules/greed.sim_manager/#property-one_found","text":"Returns: First element of the found stash, or None if the stash is empty","title":"property one_found"},{"location":"modules/greed.sim_manager/#property-states","text":"Returns: All the states in the simulation manager","title":"property states"},{"location":"modules/greed.sim_manager/#method-findall","text":"findall ( find : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6980 > , prune : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6a20 > ) Run the simulation manager, until the find condition of all the ET is met. Args: find : Function that will be called after each step. The matching states will be moved to the found stash prune : Function that will be called after each step. The matching states will be moved to the pruned stash Yield: The found states Raises: Exception : If something goes wrong while stepping the simulation manager","title":"method findall"},{"location":"modules/greed.sim_manager/#method-move","text":"move ( from_stash : str , to_stash : str , filter_func : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d63e0 > ) Move all the states that meet the filter_func condition from from_stash to to_stash Args: from_stash : Source stash to_stash : Destination Stash filter_func : A function that discriminates what states should be moved","title":"method move"},{"location":"modules/greed.sim_manager/#method-run","text":"run ( find : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d67a0 > , prune : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6840 > , find_all = False ) Run the simulation manager, until the find condition is met. The analysis will stop when there are no more active states, some states met the find condition (these will be moved to the found stash), or the exploration techniques are done. If no ET are plugged, the default searching strategy is BFS. When techniques are plugged, their methods are executed following the same order they were plugged. e.g., assuming we have T1 and T2. T1(check_stashes) -> T2(check_stashes) -> T1(check_state) -> T2(check_state) -> T1(check_successors) -> T2(check_successors) Args: find : Function that will be called after each step. The matching states will be moved to the found stash prune : Function that will be called after each step. The matching states will be moved to the pruned stash find_all : If True, the analysis will continue until all the ET meet the find condition Raises: Exception : If something goes wrong while stepping the simulation manager","title":"method run"},{"location":"modules/greed.sim_manager/#method-set_error","text":"set_error ( s : str ) Set an error to the simulation manager","title":"method set_error"},{"location":"modules/greed.sim_manager/#method-single_step_state","text":"single_step_state ( state : SymbolicEVMState ) \u2192 List [ SymbolicEVMState ] Step a single state (calculate its successors) Args: state : The state to step Returns: The successors of the state Raises: Exception : If something goes wrong while generating the successors","title":"method single_step_state"},{"location":"modules/greed.sim_manager/#method-step","text":"step ( find : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d6520 > , prune : Callable [[ SymbolicEVMState ], bool ] = < function SimulationManager .< lambda > at 0x7f79526d65c0 > ) Step the simulation manager, i.e., step all the active states. Args: find : A function that discriminates what states should be moved to the found stash prune : A function that discriminates what states should be moved to the pruned stash","title":"method step"},{"location":"modules/greed.sim_manager/#method-use_technique","text":"use_technique ( technique : 'ExplorationTechnique' ) Install an exploration technique in the simulation manager. This file was automatically generated via lazydocs .","title":"method use_technique"},{"location":"modules/greed.solver.shortcuts/","text":"module greed.solver.shortcuts This module provides shortcuts to the solver API to be used in greed scripts. function ctx_or_symbolic ctx_or_symbolic ( v , ctx , xid , nbits = 256 ) Given a variable name, if the var is in the context, return it, otherwise create a new symbolic variable. Args: v : The variable name ctx : The context xid : The transaction id nbits : The number of bits of the symbolic variable function concretize concretize ( state , val , force = False ) Given a value, if it is concrete, return it, otherwise if the symbolic variable has only one possible solution, return it. If the symbolic variable has multiple possible solutions and force is True, add a constraint and return one of the possible solutions. Args: state : The state val : The value force : Whether to force the concretization Returns: The concrete value or None function BVSort BVSort ( width ) function BVV BVV ( value , width ) function BVS BVS ( symbol , width ) function Array Array ( symbol , index_sort , value_sort ) function If If ( cond , value_if_true , value_if_false ) function Equal Equal ( a , b ) function NotEqual NotEqual ( a , b ) function Or Or ( * terms ) function And And ( * terms ) function Not Not ( a ) function bv_unsigned_value bv_unsigned_value ( bv ) function get_bv_by_name get_bv_by_name ( symbol ) function is_concrete is_concrete ( bv ) function BV_Extract BV_Extract ( start , end , bv ) function BV_Concat BV_Concat ( terms ) function BV_Add BV_Add ( a , b ) function BV_Sub BV_Sub ( a , b ) function BV_Mul BV_Mul ( a , b ) function BV_UDiv BV_UDiv ( a , b ) function BV_SDiv BV_SDiv ( a , b ) function BV_SMod BV_SMod ( a , b ) function BV_SRem BV_SRem ( a , b ) function BV_URem BV_URem ( a , b ) function BV_Sign_Extend BV_Sign_Extend ( a , b ) function BV_Zero_Extend BV_Zero_Extend ( a , b ) function BV_UGE BV_UGE ( a , b ) function BV_ULE BV_ULE ( a , b ) function BV_UGT BV_UGT ( a , b ) function BV_ULT BV_ULT ( a , b ) function BV_SGE BV_SGE ( a , b ) function BV_SLE BV_SLE ( a , b ) function BV_SGT BV_SGT ( a , b ) function BV_SLT BV_SLT ( a , b ) function BV_And BV_And ( a , b ) function BV_Or BV_Or ( a , b ) function BV_Xor BV_Xor ( a , b ) function BV_Not BV_Not ( a ) function BV_Shl BV_Shl ( a , b ) function BV_Shr BV_Shr ( a , b ) function BV_Sar BV_Sar ( a , b ) function Array_Store Array_Store ( arr , index , elem ) function Array_Select Array_Select ( arr , index ) This file was automatically generated via lazydocs .","title":"greed.solver.shortcuts"},{"location":"modules/greed.solver.shortcuts/#module-greedsolvershortcuts","text":"This module provides shortcuts to the solver API to be used in greed scripts.","title":"module greed.solver.shortcuts"},{"location":"modules/greed.solver.shortcuts/#function-ctx_or_symbolic","text":"ctx_or_symbolic ( v , ctx , xid , nbits = 256 ) Given a variable name, if the var is in the context, return it, otherwise create a new symbolic variable. Args: v : The variable name ctx : The context xid : The transaction id nbits : The number of bits of the symbolic variable","title":"function ctx_or_symbolic"},{"location":"modules/greed.solver.shortcuts/#function-concretize","text":"concretize ( state , val , force = False ) Given a value, if it is concrete, return it, otherwise if the symbolic variable has only one possible solution, return it. If the symbolic variable has multiple possible solutions and force is True, add a constraint and return one of the possible solutions. Args: state : The state val : The value force : Whether to force the concretization Returns: The concrete value or None","title":"function concretize"},{"location":"modules/greed.solver.shortcuts/#function-bvsort","text":"BVSort ( width )","title":"function BVSort"},{"location":"modules/greed.solver.shortcuts/#function-bvv","text":"BVV ( value , width )","title":"function BVV"},{"location":"modules/greed.solver.shortcuts/#function-bvs","text":"BVS ( symbol , width )","title":"function BVS"},{"location":"modules/greed.solver.shortcuts/#function-array","text":"Array ( symbol , index_sort , value_sort )","title":"function Array"},{"location":"modules/greed.solver.shortcuts/#function-if","text":"If ( cond , value_if_true , value_if_false )","title":"function If"},{"location":"modules/greed.solver.shortcuts/#function-equal","text":"Equal ( a , b )","title":"function Equal"},{"location":"modules/greed.solver.shortcuts/#function-notequal","text":"NotEqual ( a , b )","title":"function NotEqual"},{"location":"modules/greed.solver.shortcuts/#function-or","text":"Or ( * terms )","title":"function Or"},{"location":"modules/greed.solver.shortcuts/#function-and","text":"And ( * terms )","title":"function And"},{"location":"modules/greed.solver.shortcuts/#function-not","text":"Not ( a )","title":"function Not"},{"location":"modules/greed.solver.shortcuts/#function-bv_unsigned_value","text":"bv_unsigned_value ( bv )","title":"function bv_unsigned_value"},{"location":"modules/greed.solver.shortcuts/#function-get_bv_by_name","text":"get_bv_by_name ( symbol )","title":"function get_bv_by_name"},{"location":"modules/greed.solver.shortcuts/#function-is_concrete","text":"is_concrete ( bv )","title":"function is_concrete"},{"location":"modules/greed.solver.shortcuts/#function-bv_extract","text":"BV_Extract ( start , end , bv )","title":"function BV_Extract"},{"location":"modules/greed.solver.shortcuts/#function-bv_concat","text":"BV_Concat ( terms )","title":"function BV_Concat"},{"location":"modules/greed.solver.shortcuts/#function-bv_add","text":"BV_Add ( a , b )","title":"function BV_Add"},{"location":"modules/greed.solver.shortcuts/#function-bv_sub","text":"BV_Sub ( a , b )","title":"function BV_Sub"},{"location":"modules/greed.solver.shortcuts/#function-bv_mul","text":"BV_Mul ( a , b )","title":"function BV_Mul"},{"location":"modules/greed.solver.shortcuts/#function-bv_udiv","text":"BV_UDiv ( a , b )","title":"function BV_UDiv"},{"location":"modules/greed.solver.shortcuts/#function-bv_sdiv","text":"BV_SDiv ( a , b )","title":"function BV_SDiv"},{"location":"modules/greed.solver.shortcuts/#function-bv_smod","text":"BV_SMod ( a , b )","title":"function BV_SMod"},{"location":"modules/greed.solver.shortcuts/#function-bv_srem","text":"BV_SRem ( a , b )","title":"function BV_SRem"},{"location":"modules/greed.solver.shortcuts/#function-bv_urem","text":"BV_URem ( a , b )","title":"function BV_URem"},{"location":"modules/greed.solver.shortcuts/#function-bv_sign_extend","text":"BV_Sign_Extend ( a , b )","title":"function BV_Sign_Extend"},{"location":"modules/greed.solver.shortcuts/#function-bv_zero_extend","text":"BV_Zero_Extend ( a , b )","title":"function BV_Zero_Extend"},{"location":"modules/greed.solver.shortcuts/#function-bv_uge","text":"BV_UGE ( a , b )","title":"function BV_UGE"},{"location":"modules/greed.solver.shortcuts/#function-bv_ule","text":"BV_ULE ( a , b )","title":"function BV_ULE"},{"location":"modules/greed.solver.shortcuts/#function-bv_ugt","text":"BV_UGT ( a , b )","title":"function BV_UGT"},{"location":"modules/greed.solver.shortcuts/#function-bv_ult","text":"BV_ULT ( a , b )","title":"function BV_ULT"},{"location":"modules/greed.solver.shortcuts/#function-bv_sge","text":"BV_SGE ( a , b )","title":"function BV_SGE"},{"location":"modules/greed.solver.shortcuts/#function-bv_sle","text":"BV_SLE ( a , b )","title":"function BV_SLE"},{"location":"modules/greed.solver.shortcuts/#function-bv_sgt","text":"BV_SGT ( a , b )","title":"function BV_SGT"},{"location":"modules/greed.solver.shortcuts/#function-bv_slt","text":"BV_SLT ( a , b )","title":"function BV_SLT"},{"location":"modules/greed.solver.shortcuts/#function-bv_and","text":"BV_And ( a , b )","title":"function BV_And"},{"location":"modules/greed.solver.shortcuts/#function-bv_or","text":"BV_Or ( a , b )","title":"function BV_Or"},{"location":"modules/greed.solver.shortcuts/#function-bv_xor","text":"BV_Xor ( a , b )","title":"function BV_Xor"},{"location":"modules/greed.solver.shortcuts/#function-bv_not","text":"BV_Not ( a )","title":"function BV_Not"},{"location":"modules/greed.solver.shortcuts/#function-bv_shl","text":"BV_Shl ( a , b )","title":"function BV_Shl"},{"location":"modules/greed.solver.shortcuts/#function-bv_shr","text":"BV_Shr ( a , b )","title":"function BV_Shr"},{"location":"modules/greed.solver.shortcuts/#function-bv_sar","text":"BV_Sar ( a , b )","title":"function BV_Sar"},{"location":"modules/greed.solver.shortcuts/#function-array_store","text":"Array_Store ( arr , index , elem )","title":"function Array_Store"},{"location":"modules/greed.solver.shortcuts/#function-array_select","text":"Array_Select ( arr , index ) This file was automatically generated via lazydocs .","title":"function Array_Select"},{"location":"modules/greed.solver.solver/","text":"module greed.solver.solver class Solver This class represents a solver. Every solver must implement this interface. method And And ( * terms ) Return an SMT And with the given terms. Args: terms : The terms to AND method Array Array ( symbol , index_sort , value_sort ) Return an SMT Array. Args: symbol : The symbol of the array index_sort : The index sort of the array value_sort : The value sort of the array method Array_Select Array_Select ( arr , index ) Return an SMT Array_Select with the given terms. Args: arr : The array to select from index : The index to select from method Array_Store Array_Store ( arr , index , elem ) Return an SMT Array_Store with the given terms. Args: arr : The array to store to index : The index to store to elem : The element to store method BVS BVS ( symbol , width ) Return a bitvector symbol of the given width. Args: symbol : The name of the symbol width : The width of the symbol method BVSort BVSort ( width ) Return a bitvector sort of the given width. Args: width : The width of the bitvector method BVV BVV ( value , width ) Return a bitvector value of the given width. Args: value : The value of the bitvector width : The width of the bitvector method BV_Add BV_Add ( a , b ) Return a bitvector addition of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_And BV_And ( a , b ) Return a bitvector bitwise and of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_Concat BV_Concat ( terms ) Return a bitvector concatenation of the given bitvectors. Args: terms : The bitvectors to concatenate method BV_Extract BV_Extract ( start , end , bv ) Return a bitvector extract of the given bitvector. Args: start : The start of the extract end : The end of the extract bv : The bitvector to extract from method BV_Mul BV_Mul ( a , b ) Return a bitvector multiplication of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_Not BV_Not ( a ) Return a bitvector not of the given bitvector. Args: a : The bitvector to not method BV_Or BV_Or ( a , b ) Return a bitvector bitwise or of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_SDiv BV_SDiv ( a , b ) Return a bitvector signed division of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_SGE BV_SGE ( a , b ) Return a bitvector signed greater or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_SGT BV_SGT ( a , b ) Return a bitvector signed greater than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_SLE BV_SLE ( a , b ) Return a bitvector signed less or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_SLT BV_SLT ( a , b ) Return a bitvector signed less than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_SMod BV_SMod ( a , b ) Return a bitvector signed modulo of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_SRem BV_SRem ( a , b ) Return a bitvector signed remainder of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_Sar BV_Sar ( a , b ) Return a bitvector arithmetic shift right of the given bitvector. Args: a : The bitvector to shift b : The shift amount method BV_Shl BV_Shl ( a , b ) Return a bitvector shift left of the given bitvector. Args: a : The bitvector to shift b : The shift amount method BV_Shr BV_Shr ( a , b ) Return a bitvector shift right of the given bitvector. Args: a : The bitvector to shift b : The shift amount method BV_Sign_Extend BV_Sign_Extend ( a , b ) Return a bitvector sign extension of the given bitvector. Args: a : The bitvector to extend b : The width of the extension method BV_Sub BV_Sub ( a , b ) Return a bitvector subtraction of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_UDiv BV_UDiv ( a , b ) Return a bitvector unsigned division of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_UGE BV_UGE ( a , b ) Return a bitvector unsigned greater or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_UGT BV_UGT ( a , b ) Return a bitvector unsigned greater than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_ULE BV_ULE ( a , b ) Return a bitvector unsigned less or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_ULT BV_ULT ( a , b ) Return a bitvector unsigned less than of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_URem BV_URem ( a , b ) Return a bitvector unsigned remainder of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_Xor BV_Xor ( a , b ) Return a bitvector bitwise xor of the given bitvectors. Args: a : The first bitvector b : The second bitvector method BV_Zero_Extend BV_Zero_Extend ( a , b ) Return a bitvector zero extension of the given bitvector. Args: a : The bitvector to extend b : The width of the extension method Equal Equal ( a , b ) Return an SMT Equal with the given terms. Args: a : The first term b : The second term method If If ( cond , value_if_true , value_if_false ) Return an SMT If. Args: cond : The condition formula value_if_true : The value if the condition is True value_if_false : The value if the condition is False method Not Not ( a ) Return an SMT Not with the given term. Args: a : The term to NOT method NotEqual NotEqual ( a , b ) Return an SMT NotEqual with the given terms. Args: a : The first term b : The second term method Or Or ( * terms ) Return an SMT Or with the given terms. Args: terms : The terms to OR method add_assertion add_assertion ( formula ) Add a formula to the solver. Args: formula : The formula to add method add_assertions add_assertions ( formulas ) Add a list of formulas to the solver. Args: formulas : The list of formulas to add method are_formulas_sat are_formulas_sat ( terms ) Return True if the given formulas are satisfiable. Args: terms : The list of formulas to check method bv_unsigned_value bv_unsigned_value ( bv ) Return the unsigned value of the given bitvector. Args: bv : The bitvector to evaluate method copy copy () Implement the cloning of the solver when forking. method eval eval ( term ) Evaluate the given term. Args: term : The term to evaluate method get_bv_by_name get_bv_by_name ( bv ) Return the bitvector with the given name. Args: bv : The name of the bitvector method is_concrete is_concrete ( bv ) Return True if the given bitvector is concrete. Args: bv : The bitvector to check method is_formula_false is_formula_false ( formula ) Return True if the given formula is always False. Args: formula : The formula to check method is_formula_sat is_formula_sat ( formula ) Return True if the given formula is satisfiable. Args: formula : The formula to check method is_formula_true is_formula_true ( formula ) Return True if the given formula is always True. Args: formula : The formula to check method is_formula_unsat is_formula_unsat ( formula ) Return True if the given formula is unsatisfiable. Args: formula : The formula to check method is_sat is_sat () Return True if the solver is in a satisfiable state. method is_unsat is_unsat () Return True if the solver is in an unsatisfiable state. method pop pop () Pop the current context from the solver. method push push () Push a new context on the solver. method solver_timeout solver_timeout ( func ) This file was automatically generated via lazydocs .","title":"greed.solver.solver"},{"location":"modules/greed.solver.solver/#module-greedsolversolver","text":"","title":"module greed.solver.solver"},{"location":"modules/greed.solver.solver/#class-solver","text":"This class represents a solver. Every solver must implement this interface.","title":"class Solver"},{"location":"modules/greed.solver.solver/#method-and","text":"And ( * terms ) Return an SMT And with the given terms. Args: terms : The terms to AND","title":"method And"},{"location":"modules/greed.solver.solver/#method-array","text":"Array ( symbol , index_sort , value_sort ) Return an SMT Array. Args: symbol : The symbol of the array index_sort : The index sort of the array value_sort : The value sort of the array","title":"method Array"},{"location":"modules/greed.solver.solver/#method-array_select","text":"Array_Select ( arr , index ) Return an SMT Array_Select with the given terms. Args: arr : The array to select from index : The index to select from","title":"method Array_Select"},{"location":"modules/greed.solver.solver/#method-array_store","text":"Array_Store ( arr , index , elem ) Return an SMT Array_Store with the given terms. Args: arr : The array to store to index : The index to store to elem : The element to store","title":"method Array_Store"},{"location":"modules/greed.solver.solver/#method-bvs","text":"BVS ( symbol , width ) Return a bitvector symbol of the given width. Args: symbol : The name of the symbol width : The width of the symbol","title":"method BVS"},{"location":"modules/greed.solver.solver/#method-bvsort","text":"BVSort ( width ) Return a bitvector sort of the given width. Args: width : The width of the bitvector","title":"method BVSort"},{"location":"modules/greed.solver.solver/#method-bvv","text":"BVV ( value , width ) Return a bitvector value of the given width. Args: value : The value of the bitvector width : The width of the bitvector","title":"method BVV"},{"location":"modules/greed.solver.solver/#method-bv_add","text":"BV_Add ( a , b ) Return a bitvector addition of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_Add"},{"location":"modules/greed.solver.solver/#method-bv_and","text":"BV_And ( a , b ) Return a bitvector bitwise and of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_And"},{"location":"modules/greed.solver.solver/#method-bv_concat","text":"BV_Concat ( terms ) Return a bitvector concatenation of the given bitvectors. Args: terms : The bitvectors to concatenate","title":"method BV_Concat"},{"location":"modules/greed.solver.solver/#method-bv_extract","text":"BV_Extract ( start , end , bv ) Return a bitvector extract of the given bitvector. Args: start : The start of the extract end : The end of the extract bv : The bitvector to extract from","title":"method BV_Extract"},{"location":"modules/greed.solver.solver/#method-bv_mul","text":"BV_Mul ( a , b ) Return a bitvector multiplication of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_Mul"},{"location":"modules/greed.solver.solver/#method-bv_not","text":"BV_Not ( a ) Return a bitvector not of the given bitvector. Args: a : The bitvector to not","title":"method BV_Not"},{"location":"modules/greed.solver.solver/#method-bv_or","text":"BV_Or ( a , b ) Return a bitvector bitwise or of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_Or"},{"location":"modules/greed.solver.solver/#method-bv_sdiv","text":"BV_SDiv ( a , b ) Return a bitvector signed division of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_SDiv"},{"location":"modules/greed.solver.solver/#method-bv_sge","text":"BV_SGE ( a , b ) Return a bitvector signed greater or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_SGE"},{"location":"modules/greed.solver.solver/#method-bv_sgt","text":"BV_SGT ( a , b ) Return a bitvector signed greater than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_SGT"},{"location":"modules/greed.solver.solver/#method-bv_sle","text":"BV_SLE ( a , b ) Return a bitvector signed less or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_SLE"},{"location":"modules/greed.solver.solver/#method-bv_slt","text":"BV_SLT ( a , b ) Return a bitvector signed less than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_SLT"},{"location":"modules/greed.solver.solver/#method-bv_smod","text":"BV_SMod ( a , b ) Return a bitvector signed modulo of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_SMod"},{"location":"modules/greed.solver.solver/#method-bv_srem","text":"BV_SRem ( a , b ) Return a bitvector signed remainder of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_SRem"},{"location":"modules/greed.solver.solver/#method-bv_sar","text":"BV_Sar ( a , b ) Return a bitvector arithmetic shift right of the given bitvector. Args: a : The bitvector to shift b : The shift amount","title":"method BV_Sar"},{"location":"modules/greed.solver.solver/#method-bv_shl","text":"BV_Shl ( a , b ) Return a bitvector shift left of the given bitvector. Args: a : The bitvector to shift b : The shift amount","title":"method BV_Shl"},{"location":"modules/greed.solver.solver/#method-bv_shr","text":"BV_Shr ( a , b ) Return a bitvector shift right of the given bitvector. Args: a : The bitvector to shift b : The shift amount","title":"method BV_Shr"},{"location":"modules/greed.solver.solver/#method-bv_sign_extend","text":"BV_Sign_Extend ( a , b ) Return a bitvector sign extension of the given bitvector. Args: a : The bitvector to extend b : The width of the extension","title":"method BV_Sign_Extend"},{"location":"modules/greed.solver.solver/#method-bv_sub","text":"BV_Sub ( a , b ) Return a bitvector subtraction of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_Sub"},{"location":"modules/greed.solver.solver/#method-bv_udiv","text":"BV_UDiv ( a , b ) Return a bitvector unsigned division of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_UDiv"},{"location":"modules/greed.solver.solver/#method-bv_uge","text":"BV_UGE ( a , b ) Return a bitvector unsigned greater or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_UGE"},{"location":"modules/greed.solver.solver/#method-bv_ugt","text":"BV_UGT ( a , b ) Return a bitvector unsigned greater than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_UGT"},{"location":"modules/greed.solver.solver/#method-bv_ule","text":"BV_ULE ( a , b ) Return a bitvector unsigned less or equal than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_ULE"},{"location":"modules/greed.solver.solver/#method-bv_ult","text":"BV_ULT ( a , b ) Return a bitvector unsigned less than of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_ULT"},{"location":"modules/greed.solver.solver/#method-bv_urem","text":"BV_URem ( a , b ) Return a bitvector unsigned remainder of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_URem"},{"location":"modules/greed.solver.solver/#method-bv_xor","text":"BV_Xor ( a , b ) Return a bitvector bitwise xor of the given bitvectors. Args: a : The first bitvector b : The second bitvector","title":"method BV_Xor"},{"location":"modules/greed.solver.solver/#method-bv_zero_extend","text":"BV_Zero_Extend ( a , b ) Return a bitvector zero extension of the given bitvector. Args: a : The bitvector to extend b : The width of the extension","title":"method BV_Zero_Extend"},{"location":"modules/greed.solver.solver/#method-equal","text":"Equal ( a , b ) Return an SMT Equal with the given terms. Args: a : The first term b : The second term","title":"method Equal"},{"location":"modules/greed.solver.solver/#method-if","text":"If ( cond , value_if_true , value_if_false ) Return an SMT If. Args: cond : The condition formula value_if_true : The value if the condition is True value_if_false : The value if the condition is False","title":"method If"},{"location":"modules/greed.solver.solver/#method-not","text":"Not ( a ) Return an SMT Not with the given term. Args: a : The term to NOT","title":"method Not"},{"location":"modules/greed.solver.solver/#method-notequal","text":"NotEqual ( a , b ) Return an SMT NotEqual with the given terms. Args: a : The first term b : The second term","title":"method NotEqual"},{"location":"modules/greed.solver.solver/#method-or","text":"Or ( * terms ) Return an SMT Or with the given terms. Args: terms : The terms to OR","title":"method Or"},{"location":"modules/greed.solver.solver/#method-add_assertion","text":"add_assertion ( formula ) Add a formula to the solver. Args: formula : The formula to add","title":"method add_assertion"},{"location":"modules/greed.solver.solver/#method-add_assertions","text":"add_assertions ( formulas ) Add a list of formulas to the solver. Args: formulas : The list of formulas to add","title":"method add_assertions"},{"location":"modules/greed.solver.solver/#method-are_formulas_sat","text":"are_formulas_sat ( terms ) Return True if the given formulas are satisfiable. Args: terms : The list of formulas to check","title":"method are_formulas_sat"},{"location":"modules/greed.solver.solver/#method-bv_unsigned_value","text":"bv_unsigned_value ( bv ) Return the unsigned value of the given bitvector. Args: bv : The bitvector to evaluate","title":"method bv_unsigned_value"},{"location":"modules/greed.solver.solver/#method-copy","text":"copy () Implement the cloning of the solver when forking.","title":"method copy"},{"location":"modules/greed.solver.solver/#method-eval","text":"eval ( term ) Evaluate the given term. Args: term : The term to evaluate","title":"method eval"},{"location":"modules/greed.solver.solver/#method-get_bv_by_name","text":"get_bv_by_name ( bv ) Return the bitvector with the given name. Args: bv : The name of the bitvector","title":"method get_bv_by_name"},{"location":"modules/greed.solver.solver/#method-is_concrete","text":"is_concrete ( bv ) Return True if the given bitvector is concrete. Args: bv : The bitvector to check","title":"method is_concrete"},{"location":"modules/greed.solver.solver/#method-is_formula_false","text":"is_formula_false ( formula ) Return True if the given formula is always False. Args: formula : The formula to check","title":"method is_formula_false"},{"location":"modules/greed.solver.solver/#method-is_formula_sat","text":"is_formula_sat ( formula ) Return True if the given formula is satisfiable. Args: formula : The formula to check","title":"method is_formula_sat"},{"location":"modules/greed.solver.solver/#method-is_formula_true","text":"is_formula_true ( formula ) Return True if the given formula is always True. Args: formula : The formula to check","title":"method is_formula_true"},{"location":"modules/greed.solver.solver/#method-is_formula_unsat","text":"is_formula_unsat ( formula ) Return True if the given formula is unsatisfiable. Args: formula : The formula to check","title":"method is_formula_unsat"},{"location":"modules/greed.solver.solver/#method-is_sat","text":"is_sat () Return True if the solver is in a satisfiable state.","title":"method is_sat"},{"location":"modules/greed.solver.solver/#method-is_unsat","text":"is_unsat () Return True if the solver is in an unsatisfiable state.","title":"method is_unsat"},{"location":"modules/greed.solver.solver/#method-pop","text":"pop () Pop the current context from the solver.","title":"method pop"},{"location":"modules/greed.solver.solver/#method-push","text":"push () Push a new context on the solver.","title":"method push"},{"location":"modules/greed.solver.solver/#method-solver_timeout","text":"solver_timeout ( func ) This file was automatically generated via lazydocs .","title":"method solver_timeout"},{"location":"modules/greed.solver.yices2/","text":"module greed.solver.yices2 class YicesTerm method __init__ __init__ ( yices_id , operator = None , children = None , name = None , value = None ) property value method dump dump ( pp = False ) method pp pp () class YicesTermBool method __init__ __init__ ( yices_id , operator = None , children = None , name = None , value = None ) property value method dump dump ( pp = False ) method pp pp () class YicesTermBV method __init__ __init__ ( yices_id , operator = None , children = None , name = None , value = None ) property bitsize property value method dump dump ( pp = False ) method pp pp () class YicesTermArray method __init__ __init__ ( yices_id , operator = None , children = None , name = None , value = None ) property value method dump dump ( pp = False ) method pp pp () class YicesType method __init__ __init__ ( yices_id , name ) class YicesTypeBV method __init__ __init__ ( yices_id , name ) class YicesTypeArray method __init__ __init__ ( yices_id , name ) class Yices2 Backend for Yices2 For the list of options see here. https://github.com/SRI-CSL/yices2/blob/bc50bebdc3aabb161328bbfc234a10da6dd3d5c4/doc/sphinx/source/context-operations.rst self.solver.enable_option(\"var-elim\") self.solver.enable_option(\"arith-elim\") self.solver.enable_option(\"flatten\") self.solver.enable_option(\"assert-ite-bounds\") self.solver.enable_option(\"eager-arith-lemmas\") self.solver.enable_option(\"keep-ite\") self.solver.enable_option(\"bvarith-elim\") self.solver.enable_option(\"break-symmetries\") cfg.set_config(\"arith-solver\", 'simplex') method __init__ __init__ () method And And ( * terms : YicesTermBool ) \u2192 YicesTermBool method Array Array ( symbol , index_sort : YicesTypeBV , value_sort : YicesTypeBV ) \u2192 YicesTermArray method Array_Select Array_Select ( arr : YicesTermArray , index : YicesTermBV ) \u2192 YicesTermBV method Array_Store Array_Store ( arr : YicesTermArray , index : YicesTermBV , elem : YicesTermBV ) \u2192 YicesTermArray method BVS BVS ( symbol : str , width : int ) \u2192 YicesTermBV method BVSort BVSort ( width : int ) \u2192 YicesTypeBV method BVV BVV ( value : int , width : int ) \u2192 YicesTermBV method BV_Add BV_Add ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_And BV_And ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Concat BV_Concat ( terms : List [ YicesTermBV ]) \u2192 YicesTermBV method BV_Extract BV_Extract ( start : int , end : int , bv : YicesTermBV ) \u2192 YicesTermBV method BV_Mul BV_Mul ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Not BV_Not ( a : YicesTermBV ) \u2192 YicesTermBV method BV_Or BV_Or ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_SDiv BV_SDiv ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_SGE BV_SGE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_SGT BV_SGT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_SLE BV_SLE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_SLT BV_SLT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_SMod BV_SMod ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_SRem BV_SRem ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Sar BV_Sar ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Shl BV_Shl ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Shr BV_Shr ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Sign_Extend BV_Sign_Extend ( a : YicesTermBV , b : int ) \u2192 YicesTermBV method BV_Sub BV_Sub ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_UDiv BV_UDiv ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_UGE BV_UGE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_UGT BV_UGT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_ULE BV_ULE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_ULT BV_ULT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method BV_URem BV_URem ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Xor BV_Xor ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV method BV_Zero_Extend BV_Zero_Extend ( a : YicesTermBV , b : int ) \u2192 YicesTermBV method Equal Equal ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method If If ( cond : YicesTermBool , value_if_true : YicesTerm , value_if_false : YicesTerm ) \u2192 YicesTerm method Not Not ( a : YicesTermBool ) \u2192 YicesTermBool method NotEqual NotEqual ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool method Or Or ( * terms : YicesTermBool ) \u2192 YicesTermBool method add_assertion add_assertion ( formula : YicesTermBool ) method add_assertions add_assertions ( formulas : List [ YicesTermBool ]) method bv_unsigned_value bv_unsigned_value ( bv : YicesTermBV ) \u2192 int method copy copy () method eval eval ( term : YicesTerm , raw = False ) method get_bv_by_name get_bv_by_name ( symbol ) method is_concrete is_concrete ( bv : YicesTermBV ) \u2192 bool method is_formula_false is_formula_false ( formula : YicesTermBool ) \u2192 bool method is_formula_true is_formula_true ( formula : YicesTermBool ) \u2192 bool method pop pop () method push push () This file was automatically generated via lazydocs .","title":"greed.solver.yices2"},{"location":"modules/greed.solver.yices2/#module-greedsolveryices2","text":"","title":"module greed.solver.yices2"},{"location":"modules/greed.solver.yices2/#class-yicesterm","text":"","title":"class YicesTerm"},{"location":"modules/greed.solver.yices2/#method-__init__","text":"__init__ ( yices_id , operator = None , children = None , name = None , value = None )","title":"method __init__"},{"location":"modules/greed.solver.yices2/#property-value","text":"","title":"property value"},{"location":"modules/greed.solver.yices2/#method-dump","text":"dump ( pp = False )","title":"method dump"},{"location":"modules/greed.solver.yices2/#method-pp","text":"pp ()","title":"method pp"},{"location":"modules/greed.solver.yices2/#class-yicestermbool","text":"","title":"class YicesTermBool"},{"location":"modules/greed.solver.yices2/#method-__init___1","text":"__init__ ( yices_id , operator = None , children = None , name = None , value = None )","title":"method __init__"},{"location":"modules/greed.solver.yices2/#property-value_1","text":"","title":"property value"},{"location":"modules/greed.solver.yices2/#method-dump_1","text":"dump ( pp = False )","title":"method dump"},{"location":"modules/greed.solver.yices2/#method-pp_1","text":"pp ()","title":"method pp"},{"location":"modules/greed.solver.yices2/#class-yicestermbv","text":"","title":"class YicesTermBV"},{"location":"modules/greed.solver.yices2/#method-__init___2","text":"__init__ ( yices_id , operator = None , children = None , name = None , value = None )","title":"method __init__"},{"location":"modules/greed.solver.yices2/#property-bitsize","text":"","title":"property bitsize"},{"location":"modules/greed.solver.yices2/#property-value_2","text":"","title":"property value"},{"location":"modules/greed.solver.yices2/#method-dump_2","text":"dump ( pp = False )","title":"method dump"},{"location":"modules/greed.solver.yices2/#method-pp_2","text":"pp ()","title":"method pp"},{"location":"modules/greed.solver.yices2/#class-yicestermarray","text":"","title":"class YicesTermArray"},{"location":"modules/greed.solver.yices2/#method-__init___3","text":"__init__ ( yices_id , operator = None , children = None , name = None , value = None )","title":"method __init__"},{"location":"modules/greed.solver.yices2/#property-value_3","text":"","title":"property value"},{"location":"modules/greed.solver.yices2/#method-dump_3","text":"dump ( pp = False )","title":"method dump"},{"location":"modules/greed.solver.yices2/#method-pp_3","text":"pp ()","title":"method pp"},{"location":"modules/greed.solver.yices2/#class-yicestype","text":"","title":"class YicesType"},{"location":"modules/greed.solver.yices2/#method-__init___4","text":"__init__ ( yices_id , name )","title":"method __init__"},{"location":"modules/greed.solver.yices2/#class-yicestypebv","text":"","title":"class YicesTypeBV"},{"location":"modules/greed.solver.yices2/#method-__init___5","text":"__init__ ( yices_id , name )","title":"method __init__"},{"location":"modules/greed.solver.yices2/#class-yicestypearray","text":"","title":"class YicesTypeArray"},{"location":"modules/greed.solver.yices2/#method-__init___6","text":"__init__ ( yices_id , name )","title":"method __init__"},{"location":"modules/greed.solver.yices2/#class-yices2","text":"Backend for Yices2 For the list of options see here. https://github.com/SRI-CSL/yices2/blob/bc50bebdc3aabb161328bbfc234a10da6dd3d5c4/doc/sphinx/source/context-operations.rst self.solver.enable_option(\"var-elim\") self.solver.enable_option(\"arith-elim\") self.solver.enable_option(\"flatten\") self.solver.enable_option(\"assert-ite-bounds\") self.solver.enable_option(\"eager-arith-lemmas\") self.solver.enable_option(\"keep-ite\") self.solver.enable_option(\"bvarith-elim\") self.solver.enable_option(\"break-symmetries\") cfg.set_config(\"arith-solver\", 'simplex')","title":"class Yices2"},{"location":"modules/greed.solver.yices2/#method-__init___7","text":"__init__ ()","title":"method __init__"},{"location":"modules/greed.solver.yices2/#method-and","text":"And ( * terms : YicesTermBool ) \u2192 YicesTermBool","title":"method And"},{"location":"modules/greed.solver.yices2/#method-array","text":"Array ( symbol , index_sort : YicesTypeBV , value_sort : YicesTypeBV ) \u2192 YicesTermArray","title":"method Array"},{"location":"modules/greed.solver.yices2/#method-array_select","text":"Array_Select ( arr : YicesTermArray , index : YicesTermBV ) \u2192 YicesTermBV","title":"method Array_Select"},{"location":"modules/greed.solver.yices2/#method-array_store","text":"Array_Store ( arr : YicesTermArray , index : YicesTermBV , elem : YicesTermBV ) \u2192 YicesTermArray","title":"method Array_Store"},{"location":"modules/greed.solver.yices2/#method-bvs","text":"BVS ( symbol : str , width : int ) \u2192 YicesTermBV","title":"method BVS"},{"location":"modules/greed.solver.yices2/#method-bvsort","text":"BVSort ( width : int ) \u2192 YicesTypeBV","title":"method BVSort"},{"location":"modules/greed.solver.yices2/#method-bvv","text":"BVV ( value : int , width : int ) \u2192 YicesTermBV","title":"method BVV"},{"location":"modules/greed.solver.yices2/#method-bv_add","text":"BV_Add ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Add"},{"location":"modules/greed.solver.yices2/#method-bv_and","text":"BV_And ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_And"},{"location":"modules/greed.solver.yices2/#method-bv_concat","text":"BV_Concat ( terms : List [ YicesTermBV ]) \u2192 YicesTermBV","title":"method BV_Concat"},{"location":"modules/greed.solver.yices2/#method-bv_extract","text":"BV_Extract ( start : int , end : int , bv : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Extract"},{"location":"modules/greed.solver.yices2/#method-bv_mul","text":"BV_Mul ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Mul"},{"location":"modules/greed.solver.yices2/#method-bv_not","text":"BV_Not ( a : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Not"},{"location":"modules/greed.solver.yices2/#method-bv_or","text":"BV_Or ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Or"},{"location":"modules/greed.solver.yices2/#method-bv_sdiv","text":"BV_SDiv ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_SDiv"},{"location":"modules/greed.solver.yices2/#method-bv_sge","text":"BV_SGE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_SGE"},{"location":"modules/greed.solver.yices2/#method-bv_sgt","text":"BV_SGT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_SGT"},{"location":"modules/greed.solver.yices2/#method-bv_sle","text":"BV_SLE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_SLE"},{"location":"modules/greed.solver.yices2/#method-bv_slt","text":"BV_SLT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_SLT"},{"location":"modules/greed.solver.yices2/#method-bv_smod","text":"BV_SMod ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_SMod"},{"location":"modules/greed.solver.yices2/#method-bv_srem","text":"BV_SRem ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_SRem"},{"location":"modules/greed.solver.yices2/#method-bv_sar","text":"BV_Sar ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Sar"},{"location":"modules/greed.solver.yices2/#method-bv_shl","text":"BV_Shl ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Shl"},{"location":"modules/greed.solver.yices2/#method-bv_shr","text":"BV_Shr ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Shr"},{"location":"modules/greed.solver.yices2/#method-bv_sign_extend","text":"BV_Sign_Extend ( a : YicesTermBV , b : int ) \u2192 YicesTermBV","title":"method BV_Sign_Extend"},{"location":"modules/greed.solver.yices2/#method-bv_sub","text":"BV_Sub ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Sub"},{"location":"modules/greed.solver.yices2/#method-bv_udiv","text":"BV_UDiv ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_UDiv"},{"location":"modules/greed.solver.yices2/#method-bv_uge","text":"BV_UGE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_UGE"},{"location":"modules/greed.solver.yices2/#method-bv_ugt","text":"BV_UGT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_UGT"},{"location":"modules/greed.solver.yices2/#method-bv_ule","text":"BV_ULE ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_ULE"},{"location":"modules/greed.solver.yices2/#method-bv_ult","text":"BV_ULT ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method BV_ULT"},{"location":"modules/greed.solver.yices2/#method-bv_urem","text":"BV_URem ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_URem"},{"location":"modules/greed.solver.yices2/#method-bv_xor","text":"BV_Xor ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBV","title":"method BV_Xor"},{"location":"modules/greed.solver.yices2/#method-bv_zero_extend","text":"BV_Zero_Extend ( a : YicesTermBV , b : int ) \u2192 YicesTermBV","title":"method BV_Zero_Extend"},{"location":"modules/greed.solver.yices2/#method-equal","text":"Equal ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method Equal"},{"location":"modules/greed.solver.yices2/#method-if","text":"If ( cond : YicesTermBool , value_if_true : YicesTerm , value_if_false : YicesTerm ) \u2192 YicesTerm","title":"method If"},{"location":"modules/greed.solver.yices2/#method-not","text":"Not ( a : YicesTermBool ) \u2192 YicesTermBool","title":"method Not"},{"location":"modules/greed.solver.yices2/#method-notequal","text":"NotEqual ( a : YicesTermBV , b : YicesTermBV ) \u2192 YicesTermBool","title":"method NotEqual"},{"location":"modules/greed.solver.yices2/#method-or","text":"Or ( * terms : YicesTermBool ) \u2192 YicesTermBool","title":"method Or"},{"location":"modules/greed.solver.yices2/#method-add_assertion","text":"add_assertion ( formula : YicesTermBool )","title":"method add_assertion"},{"location":"modules/greed.solver.yices2/#method-add_assertions","text":"add_assertions ( formulas : List [ YicesTermBool ])","title":"method add_assertions"},{"location":"modules/greed.solver.yices2/#method-bv_unsigned_value","text":"bv_unsigned_value ( bv : YicesTermBV ) \u2192 int","title":"method bv_unsigned_value"},{"location":"modules/greed.solver.yices2/#method-copy","text":"copy ()","title":"method copy"},{"location":"modules/greed.solver.yices2/#method-eval","text":"eval ( term : YicesTerm , raw = False )","title":"method eval"},{"location":"modules/greed.solver.yices2/#method-get_bv_by_name","text":"get_bv_by_name ( symbol )","title":"method get_bv_by_name"},{"location":"modules/greed.solver.yices2/#method-is_concrete","text":"is_concrete ( bv : YicesTermBV ) \u2192 bool","title":"method is_concrete"},{"location":"modules/greed.solver.yices2/#method-is_formula_false","text":"is_formula_false ( formula : YicesTermBool ) \u2192 bool","title":"method is_formula_false"},{"location":"modules/greed.solver.yices2/#method-is_formula_true","text":"is_formula_true ( formula : YicesTermBool ) \u2192 bool","title":"method is_formula_true"},{"location":"modules/greed.solver.yices2/#method-pop","text":"pop ()","title":"method pop"},{"location":"modules/greed.solver.yices2/#method-push","text":"push () This file was automatically generated via lazydocs .","title":"method push"},{"location":"modules/greed.state/","text":"module greed.state class SymbolicEVMState This class represents a symbolic EVM state (SimState). method __init__ __init__ ( xid , project , partial_init = False , init_ctx = None , options = None , max_calldatasize = None , partial_concrete_storage = False ) Args: xid : The execution id project : the greed project partial_init : Whether to partially initialize the object or not init_ctx : The initial context of the state (e.g., CALLER, ADDRESS, BALANCE, etc.) options : The options for this state max_calldatasize : The maximum size of the calldata partial_concrete_storage : Whether to use the partial concrete storage or not property constraints property curr_stmt property pc method add_constraint add_constraint ( constraint ) This method adds a constraint to the state. method copy copy () Deep copy of the SimState. method get_fallthrough_pc get_fallthrough_pc () This method returns the fallthrough pc of the current state method get_non_fallthrough_pc get_non_fallthrough_pc ( destination_val ) This method returns the non fallthrough pc of the current state. method register_plugin register_plugin ( name : str , plugin : SimStatePlugin ) This method registers a plugin to the state. method reset reset ( xid ) This method resets the state. method set_init_ctx set_init_ctx ( init_ctx = None ) This method applies the initial context to the state. Args: init_ctx : A dict storing the initial context of the state (e.g., CALLER, ADDRESS, BALANCE, etc.) method set_next_pc set_next_pc () This method sets the next pc to the state. Raises: VMNoSuccessors : If there are no successors VMUnexpectedSuccessors : If the successor does not match any of the expected successors This file was automatically generated via lazydocs .","title":"greed.state"},{"location":"modules/greed.state/#module-greedstate","text":"","title":"module greed.state"},{"location":"modules/greed.state/#class-symbolicevmstate","text":"This class represents a symbolic EVM state (SimState).","title":"class SymbolicEVMState"},{"location":"modules/greed.state/#method-__init__","text":"__init__ ( xid , project , partial_init = False , init_ctx = None , options = None , max_calldatasize = None , partial_concrete_storage = False ) Args: xid : The execution id project : the greed project partial_init : Whether to partially initialize the object or not init_ctx : The initial context of the state (e.g., CALLER, ADDRESS, BALANCE, etc.) options : The options for this state max_calldatasize : The maximum size of the calldata partial_concrete_storage : Whether to use the partial concrete storage or not","title":"method __init__"},{"location":"modules/greed.state/#property-constraints","text":"","title":"property constraints"},{"location":"modules/greed.state/#property-curr_stmt","text":"","title":"property curr_stmt"},{"location":"modules/greed.state/#property-pc","text":"","title":"property pc"},{"location":"modules/greed.state/#method-add_constraint","text":"add_constraint ( constraint ) This method adds a constraint to the state.","title":"method add_constraint"},{"location":"modules/greed.state/#method-copy","text":"copy () Deep copy of the SimState.","title":"method copy"},{"location":"modules/greed.state/#method-get_fallthrough_pc","text":"get_fallthrough_pc () This method returns the fallthrough pc of the current state","title":"method get_fallthrough_pc"},{"location":"modules/greed.state/#method-get_non_fallthrough_pc","text":"get_non_fallthrough_pc ( destination_val ) This method returns the non fallthrough pc of the current state.","title":"method get_non_fallthrough_pc"},{"location":"modules/greed.state/#method-register_plugin","text":"register_plugin ( name : str , plugin : SimStatePlugin ) This method registers a plugin to the state.","title":"method register_plugin"},{"location":"modules/greed.state/#method-reset","text":"reset ( xid ) This method resets the state.","title":"method reset"},{"location":"modules/greed.state/#method-set_init_ctx","text":"set_init_ctx ( init_ctx = None ) This method applies the initial context to the state. Args: init_ctx : A dict storing the initial context of the state (e.g., CALLER, ADDRESS, BALANCE, etc.)","title":"method set_init_ctx"},{"location":"modules/greed.state/#method-set_next_pc","text":"set_next_pc () This method sets the next pc to the state. Raises: VMNoSuccessors : If there are no successors VMUnexpectedSuccessors : If the successor does not match any of the expected successors This file was automatically generated via lazydocs .","title":"method set_next_pc"},{"location":"modules/greed.state_plugins.globals/","text":"module greed.state_plugins.globals class SimStateGlobals A plugin that allows for global variables to be stored in the state. This will act like a dictionary. method __init__ __init__ ( backer = None ) method copy copy () Get a deep-copy of this plugin. method get get ( k , alt = None ) Get the value of a global variable, or return an alternative value. Args: k : The name of the global variable. alt : The alternative value to return if the global variable does not exist. method items items () Get the names and values of all global variables. method keys keys () Get the names of all global variables. method pop pop ( k , alt = None ) Get the value of a global variable, and remove it from the state. Args: k : The name of the global variable. alt : The alternative value to return if the global variable does not exist. method values values () Get the values of all global variables. This file was automatically generated via lazydocs .","title":"greed.state_plugins.globals"},{"location":"modules/greed.state_plugins.globals/#module-greedstate_pluginsglobals","text":"","title":"module greed.state_plugins.globals"},{"location":"modules/greed.state_plugins.globals/#class-simstateglobals","text":"A plugin that allows for global variables to be stored in the state. This will act like a dictionary.","title":"class SimStateGlobals"},{"location":"modules/greed.state_plugins.globals/#method-__init__","text":"__init__ ( backer = None )","title":"method __init__"},{"location":"modules/greed.state_plugins.globals/#method-copy","text":"copy () Get a deep-copy of this plugin.","title":"method copy"},{"location":"modules/greed.state_plugins.globals/#method-get","text":"get ( k , alt = None ) Get the value of a global variable, or return an alternative value. Args: k : The name of the global variable. alt : The alternative value to return if the global variable does not exist.","title":"method get"},{"location":"modules/greed.state_plugins.globals/#method-items","text":"items () Get the names and values of all global variables.","title":"method items"},{"location":"modules/greed.state_plugins.globals/#method-keys","text":"keys () Get the names of all global variables.","title":"method keys"},{"location":"modules/greed.state_plugins.globals/#method-pop","text":"pop ( k , alt = None ) Get the value of a global variable, and remove it from the state. Args: k : The name of the global variable. alt : The alternative value to return if the global variable does not exist.","title":"method pop"},{"location":"modules/greed.state_plugins.globals/#method-values","text":"values () Get the values of all global variables. This file was automatically generated via lazydocs .","title":"method values"},{"location":"modules/greed.state_plugins.inspect/","text":"module greed.state_plugins.inspect Global Variables OP_BEFORE OP_AFTER class SimStateInspect A plugin that allows for breakpoints to be set on statements. method __init__ __init__ ( breakpoints_stmt_ids = None , breakpoints_stmt = None ) method copy copy () Deep copy this state plugin. method stop_at_stmt stop_at_stmt ( stmt_name = None , func = None , when = 0 ) Stop at a statement with a given name (e.g., CALL) Args: stmt_name : The name of the statement to stop at. func : The function to call when the breakpoint is hit (default: ipdb.set_trace()) when : Whether to stop before or after the statement. method stop_at_stmt_id stop_at_stmt_id ( stmt_id = None , func = None , when = 0 ) Stop at a statement with a given ID (i.e., PC) Args: stmt_id : The ID of the statement to stop at. func : The function to call when the breakpoint is hit. when : Whether to stop before or after the statement. The default function if none is provided is: ''' def justStop(simgr, state): log.warning(\"\ud83d\udca5 Triggered breakpoint at {}\".format(state.pc)) import ipdb; ipdb.set_trace() ''' This file was automatically generated via lazydocs .","title":"greed.state_plugins.inspect"},{"location":"modules/greed.state_plugins.inspect/#module-greedstate_pluginsinspect","text":"","title":"module greed.state_plugins.inspect"},{"location":"modules/greed.state_plugins.inspect/#global-variables","text":"OP_BEFORE OP_AFTER","title":"Global Variables"},{"location":"modules/greed.state_plugins.inspect/#class-simstateinspect","text":"A plugin that allows for breakpoints to be set on statements.","title":"class SimStateInspect"},{"location":"modules/greed.state_plugins.inspect/#method-__init__","text":"__init__ ( breakpoints_stmt_ids = None , breakpoints_stmt = None )","title":"method __init__"},{"location":"modules/greed.state_plugins.inspect/#method-copy","text":"copy () Deep copy this state plugin.","title":"method copy"},{"location":"modules/greed.state_plugins.inspect/#method-stop_at_stmt","text":"stop_at_stmt ( stmt_name = None , func = None , when = 0 ) Stop at a statement with a given name (e.g., CALL) Args: stmt_name : The name of the statement to stop at. func : The function to call when the breakpoint is hit (default: ipdb.set_trace()) when : Whether to stop before or after the statement.","title":"method stop_at_stmt"},{"location":"modules/greed.state_plugins.inspect/#method-stop_at_stmt_id","text":"stop_at_stmt_id ( stmt_id = None , func = None , when = 0 ) Stop at a statement with a given ID (i.e., PC) Args: stmt_id : The ID of the statement to stop at. func : The function to call when the breakpoint is hit. when : Whether to stop before or after the statement. The default function if none is provided is: ''' def justStop(simgr, state): log.warning(\"\ud83d\udca5 Triggered breakpoint at {}\".format(state.pc)) import ipdb; ipdb.set_trace() ''' This file was automatically generated via lazydocs .","title":"method stop_at_stmt_id"},{"location":"modules/greed.state_plugins.plugin/","text":"module greed.state_plugins.plugin class SimStatePlugin Interface for SimState plugins. method __init__ __init__ () method copy copy () method set_state set_state ( state ) This file was automatically generated via lazydocs .","title":"greed.state_plugins.plugin"},{"location":"modules/greed.state_plugins.plugin/#module-greedstate_pluginsplugin","text":"","title":"module greed.state_plugins.plugin"},{"location":"modules/greed.state_plugins.plugin/#class-simstateplugin","text":"Interface for SimState plugins.","title":"class SimStatePlugin"},{"location":"modules/greed.state_plugins.plugin/#method-__init__","text":"__init__ ()","title":"method __init__"},{"location":"modules/greed.state_plugins.plugin/#method-copy","text":"copy ()","title":"method copy"},{"location":"modules/greed.state_plugins.plugin/#method-set_state","text":"set_state ( state ) This file was automatically generated via lazydocs .","title":"method set_state"},{"location":"modules/greed.state_plugins.sha_resolver/","text":"module greed.state_plugins.sha_resolver class ShaSolution method __init__ __init__ ( symbol_name , argOffset , argSize , inputBuffer , shaResult ) class ShaResolver A plugin that finds solutions for the observed sha3 operations in a SimState. method __init__ __init__ ( breakpoints_stmt_ids = None , breakpoints_stmt = None ) method clear_sha_frame clear_sha_frame () method clear_solutions clear_solutions () method copy copy () Deep copy this state plugin. method fix_shas fix_shas () method get_keccak256 get_keccak256 ( input_buffer , sha_size ) This file was automatically generated via lazydocs .","title":"greed.state_plugins.sha_resolver"},{"location":"modules/greed.state_plugins.sha_resolver/#module-greedstate_pluginssha_resolver","text":"","title":"module greed.state_plugins.sha_resolver"},{"location":"modules/greed.state_plugins.sha_resolver/#class-shasolution","text":"","title":"class ShaSolution"},{"location":"modules/greed.state_plugins.sha_resolver/#method-__init__","text":"__init__ ( symbol_name , argOffset , argSize , inputBuffer , shaResult )","title":"method __init__"},{"location":"modules/greed.state_plugins.sha_resolver/#class-sharesolver","text":"A plugin that finds solutions for the observed sha3 operations in a SimState.","title":"class ShaResolver"},{"location":"modules/greed.state_plugins.sha_resolver/#method-__init___1","text":"__init__ ( breakpoints_stmt_ids = None , breakpoints_stmt = None )","title":"method __init__"},{"location":"modules/greed.state_plugins.sha_resolver/#method-clear_sha_frame","text":"clear_sha_frame ()","title":"method clear_sha_frame"},{"location":"modules/greed.state_plugins.sha_resolver/#method-clear_solutions","text":"clear_solutions ()","title":"method clear_solutions"},{"location":"modules/greed.state_plugins.sha_resolver/#method-copy","text":"copy () Deep copy this state plugin.","title":"method copy"},{"location":"modules/greed.state_plugins.sha_resolver/#method-fix_shas","text":"fix_shas ()","title":"method fix_shas"},{"location":"modules/greed.state_plugins.sha_resolver/#method-get_keccak256","text":"get_keccak256 ( input_buffer , sha_size ) This file was automatically generated via lazydocs .","title":"method get_keccak256"},{"location":"modules/greed.state_plugins.solver/","text":"module greed.state_plugins.solver class SimStateSolver A plugin that allows for constraints to be added to the state and unified access to the solver backend. method __init__ __init__ ( partial_init = False ) property constraints property frame property memory_constraints property path_constraints property timed_out method add_memory_constraints add_memory_constraints ( constraint ) Add a memory constraint to the state (at the current frame level). Args: constraint : The constraint to add. method add_path_constraints add_path_constraints ( constraint ) Add a path constraint to the state (at the current frame level). Args: constraint : The constraint to add. method are_formulas_sat are_formulas_sat ( terms ) \u2192 bool Check if a list of formulas is satisfiable given the current state of the solver. Args: terms : The list of formulas to check. method constraints_at constraints_at ( frame = None ) Returns the constraints at a specific frame or all the constraints if frame is None. Args: frame : The frame level in the solver to check. method copy copy () \u2192 SimStateSolver Deep copy this state plugin. method dispose_context dispose_context () Dispose the solver context. method eval eval ( term , raw = False ) Evaluate a term. Args: term : The term to evaluate. raw : If True, return the raw value of the term. Returns: The evaluated term. method eval_memory eval_memory ( memory , length , raw = False ) Evaluate a memory region in the memory. Args: memory : The memory region to evaluate. length : The length of the memory region to evaluate. raw : If True, return the raw value of the memory region. Returns: The evaluated memory region. Raises: AssertionError : If the length is not concrete. method eval_memory_at eval_memory_at ( array , offset , length , raw = False ) Evaluate a portion of a memory region starting at a given offset. Args: array : The memory region to evaluate. offset : The offset to start evaluating from. length : The length of the memory region to evaluate. raw : If True, return the raw value of the memory region. Returns: The evaluated memory region. Raises: AssertionError : If the offset or the length is not concrete. method is_concrete is_concrete ( term ) \u2192 bool Check if a term is concrete. method is_formula_false is_formula_false ( formula ) \u2192 bool Check if a formula is false given the current state of the solver. Args: formula : The formula to check. method is_formula_sat is_formula_sat ( formula ) \u2192 bool Check if a formula is satisfiable given the current state of the solver. Args: formula : The formula to check. method is_formula_true is_formula_true ( formula ) \u2192 bool Check if a formula is true given the current state of the solver. Args: formula : The formula to check. method is_formula_unsat is_formula_unsat ( formula ) \u2192 bool Check if a formula is unsatisfiable given the current state of the solver. Args: formula : The formula to check. method is_sat is_sat () \u2192 bool Check if the solver is in a satisfiable state. method is_unsat is_unsat () \u2192 bool Check if the solver is in an unsatisfiable state. method memory_constraints_at memory_constraints_at ( frame = None ) Returns the memory constraints at a specific frame. If frame is None, returns ALL the currently active memory constraints. Args: frame : The frame level in the solver to check. method path_constraints_at path_constraints_at ( frame : int = None ) Returns the path constraints at a specific frame. If frame is None, returns ALL the currently active path constraints. Args: frame : The frame level in the solver to check. method pop pop () \u2192 int Pop a frame from the solver stack. method pop_all pop_all () Pop all the frames from the solver stack. method push push () \u2192 int Push a new frame on the solver stack. method simplify simplify () Simplify registers by replacing them with their concrete values if possible. This file was automatically generated via lazydocs .","title":"greed.state_plugins.solver"},{"location":"modules/greed.state_plugins.solver/#module-greedstate_pluginssolver","text":"","title":"module greed.state_plugins.solver"},{"location":"modules/greed.state_plugins.solver/#class-simstatesolver","text":"A plugin that allows for constraints to be added to the state and unified access to the solver backend.","title":"class SimStateSolver"},{"location":"modules/greed.state_plugins.solver/#method-__init__","text":"__init__ ( partial_init = False )","title":"method __init__"},{"location":"modules/greed.state_plugins.solver/#property-constraints","text":"","title":"property constraints"},{"location":"modules/greed.state_plugins.solver/#property-frame","text":"","title":"property frame"},{"location":"modules/greed.state_plugins.solver/#property-memory_constraints","text":"","title":"property memory_constraints"},{"location":"modules/greed.state_plugins.solver/#property-path_constraints","text":"","title":"property path_constraints"},{"location":"modules/greed.state_plugins.solver/#property-timed_out","text":"","title":"property timed_out"},{"location":"modules/greed.state_plugins.solver/#method-add_memory_constraints","text":"add_memory_constraints ( constraint ) Add a memory constraint to the state (at the current frame level). Args: constraint : The constraint to add.","title":"method add_memory_constraints"},{"location":"modules/greed.state_plugins.solver/#method-add_path_constraints","text":"add_path_constraints ( constraint ) Add a path constraint to the state (at the current frame level). Args: constraint : The constraint to add.","title":"method add_path_constraints"},{"location":"modules/greed.state_plugins.solver/#method-are_formulas_sat","text":"are_formulas_sat ( terms ) \u2192 bool Check if a list of formulas is satisfiable given the current state of the solver. Args: terms : The list of formulas to check.","title":"method are_formulas_sat"},{"location":"modules/greed.state_plugins.solver/#method-constraints_at","text":"constraints_at ( frame = None ) Returns the constraints at a specific frame or all the constraints if frame is None. Args: frame : The frame level in the solver to check.","title":"method constraints_at"},{"location":"modules/greed.state_plugins.solver/#method-copy","text":"copy () \u2192 SimStateSolver Deep copy this state plugin.","title":"method copy"},{"location":"modules/greed.state_plugins.solver/#method-dispose_context","text":"dispose_context () Dispose the solver context.","title":"method dispose_context"},{"location":"modules/greed.state_plugins.solver/#method-eval","text":"eval ( term , raw = False ) Evaluate a term. Args: term : The term to evaluate. raw : If True, return the raw value of the term. Returns: The evaluated term.","title":"method eval"},{"location":"modules/greed.state_plugins.solver/#method-eval_memory","text":"eval_memory ( memory , length , raw = False ) Evaluate a memory region in the memory. Args: memory : The memory region to evaluate. length : The length of the memory region to evaluate. raw : If True, return the raw value of the memory region. Returns: The evaluated memory region. Raises: AssertionError : If the length is not concrete.","title":"method eval_memory"},{"location":"modules/greed.state_plugins.solver/#method-eval_memory_at","text":"eval_memory_at ( array , offset , length , raw = False ) Evaluate a portion of a memory region starting at a given offset. Args: array : The memory region to evaluate. offset : The offset to start evaluating from. length : The length of the memory region to evaluate. raw : If True, return the raw value of the memory region. Returns: The evaluated memory region. Raises: AssertionError : If the offset or the length is not concrete.","title":"method eval_memory_at"},{"location":"modules/greed.state_plugins.solver/#method-is_concrete","text":"is_concrete ( term ) \u2192 bool Check if a term is concrete.","title":"method is_concrete"},{"location":"modules/greed.state_plugins.solver/#method-is_formula_false","text":"is_formula_false ( formula ) \u2192 bool Check if a formula is false given the current state of the solver. Args: formula : The formula to check.","title":"method is_formula_false"},{"location":"modules/greed.state_plugins.solver/#method-is_formula_sat","text":"is_formula_sat ( formula ) \u2192 bool Check if a formula is satisfiable given the current state of the solver. Args: formula : The formula to check.","title":"method is_formula_sat"},{"location":"modules/greed.state_plugins.solver/#method-is_formula_true","text":"is_formula_true ( formula ) \u2192 bool Check if a formula is true given the current state of the solver. Args: formula : The formula to check.","title":"method is_formula_true"},{"location":"modules/greed.state_plugins.solver/#method-is_formula_unsat","text":"is_formula_unsat ( formula ) \u2192 bool Check if a formula is unsatisfiable given the current state of the solver. Args: formula : The formula to check.","title":"method is_formula_unsat"},{"location":"modules/greed.state_plugins.solver/#method-is_sat","text":"is_sat () \u2192 bool Check if the solver is in a satisfiable state.","title":"method is_sat"},{"location":"modules/greed.state_plugins.solver/#method-is_unsat","text":"is_unsat () \u2192 bool Check if the solver is in an unsatisfiable state.","title":"method is_unsat"},{"location":"modules/greed.state_plugins.solver/#method-memory_constraints_at","text":"memory_constraints_at ( frame = None ) Returns the memory constraints at a specific frame. If frame is None, returns ALL the currently active memory constraints. Args: frame : The frame level in the solver to check.","title":"method memory_constraints_at"},{"location":"modules/greed.state_plugins.solver/#method-path_constraints_at","text":"path_constraints_at ( frame : int = None ) Returns the path constraints at a specific frame. If frame is None, returns ALL the currently active path constraints. Args: frame : The frame level in the solver to check.","title":"method path_constraints_at"},{"location":"modules/greed.state_plugins.solver/#method-pop","text":"pop () \u2192 int Pop a frame from the solver stack.","title":"method pop"},{"location":"modules/greed.state_plugins.solver/#method-pop_all","text":"pop_all () Pop all the frames from the solver stack.","title":"method pop_all"},{"location":"modules/greed.state_plugins.solver/#method-push","text":"push () \u2192 int Push a new frame on the solver stack.","title":"method push"},{"location":"modules/greed.state_plugins.solver/#method-simplify","text":"simplify () Simplify registers by replacing them with their concrete values if possible. This file was automatically generated via lazydocs .","title":"method simplify"},{"location":"modules/greed.utils.encoding/","text":"module greed.utils.encoding function addr addr ( expr ) This file was automatically generated via lazydocs .","title":"greed.utils.encoding"},{"location":"modules/greed.utils.encoding/#module-greedutilsencoding","text":"","title":"module greed.utils.encoding"},{"location":"modules/greed.utils.encoding/#function-addr","text":"addr ( expr ) This file was automatically generated via lazydocs .","title":"function addr"},{"location":"modules/greed.utils.exceptions/","text":"module greed.utils.exceptions class VMException class VMNoSuccessors class VMUnexpectedSuccessors class VMSymbolicError class VMExternalData class GreedException class SolverTimeout This file was automatically generated via lazydocs .","title":"greed.utils.exceptions"},{"location":"modules/greed.utils.exceptions/#module-greedutilsexceptions","text":"","title":"module greed.utils.exceptions"},{"location":"modules/greed.utils.exceptions/#class-vmexception","text":"","title":"class VMException"},{"location":"modules/greed.utils.exceptions/#class-vmnosuccessors","text":"","title":"class VMNoSuccessors"},{"location":"modules/greed.utils.exceptions/#class-vmunexpectedsuccessors","text":"","title":"class VMUnexpectedSuccessors"},{"location":"modules/greed.utils.exceptions/#class-vmsymbolicerror","text":"","title":"class VMSymbolicError"},{"location":"modules/greed.utils.exceptions/#class-vmexternaldata","text":"","title":"class VMExternalData"},{"location":"modules/greed.utils.exceptions/#class-greedexception","text":"","title":"class GreedException"},{"location":"modules/greed.utils.exceptions/#class-solvertimeout","text":"This file was automatically generated via lazydocs .","title":"class SolverTimeout"},{"location":"modules/greed.utils.extra/","text":"module greed.utils.extra Global Variables XID_GENERATOR function gen_exec_id gen_exec_id () function is_pow2 is_pow2 ( x ) function log2 log2 ( x ) class UUIDGenerator method __init__ __init__ () method next next () This file was automatically generated via lazydocs .","title":"greed.utils.extra"},{"location":"modules/greed.utils.extra/#module-greedutilsextra","text":"","title":"module greed.utils.extra"},{"location":"modules/greed.utils.extra/#global-variables","text":"XID_GENERATOR","title":"Global Variables"},{"location":"modules/greed.utils.extra/#function-gen_exec_id","text":"gen_exec_id ()","title":"function gen_exec_id"},{"location":"modules/greed.utils.extra/#function-is_pow2","text":"is_pow2 ( x )","title":"function is_pow2"},{"location":"modules/greed.utils.extra/#function-log2","text":"log2 ( x )","title":"function log2"},{"location":"modules/greed.utils.extra/#class-uuidgenerator","text":"","title":"class UUIDGenerator"},{"location":"modules/greed.utils.extra/#method-__init__","text":"__init__ ()","title":"method __init__"},{"location":"modules/greed.utils.extra/#method-next","text":"next () This file was automatically generated via lazydocs .","title":"method next"},{"location":"modules/greed.utils.files/","text":"module greed.utils.files function load_csv load_csv ( path : str , seperator : str = ' \\t ' ) \u2192 List [ Union [ str , List [ str ]]] function load_csv_map load_csv_map ( path : str , seperator : str = ' \\t ' , reverse : bool = False ) \u2192 Mapping [ str , str ] function load_csv_multimap load_csv_multimap ( path : str , seperator : str = ' \\t ' , reverse : bool = False ) \u2192 Mapping [ str , List [ str ]] This file was automatically generated via lazydocs .","title":"greed.utils.files"},{"location":"modules/greed.utils.files/#module-greedutilsfiles","text":"","title":"module greed.utils.files"},{"location":"modules/greed.utils.files/#function-load_csv","text":"load_csv ( path : str , seperator : str = ' \\t ' ) \u2192 List [ Union [ str , List [ str ]]]","title":"function load_csv"},{"location":"modules/greed.utils.files/#function-load_csv_map","text":"load_csv_map ( path : str , seperator : str = ' \\t ' , reverse : bool = False ) \u2192 Mapping [ str , str ]","title":"function load_csv_map"},{"location":"modules/greed.utils.files/#function-load_csv_multimap","text":"load_csv_multimap ( path : str , seperator : str = ' \\t ' , reverse : bool = False ) \u2192 Mapping [ str , List [ str ]] This file was automatically generated via lazydocs .","title":"function load_csv_multimap"}]}